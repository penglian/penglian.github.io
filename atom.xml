<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Penglian的博客</title>
  <icon>https://www.gravatar.com/avatar/e535e1a14e9c89335ced6c415a4d9735</icon>
  <subtitle>我不仅仅是一个码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//plstyle.cn/"/>
  <updated>2018-11-03T12:19:54.792Z</updated>
  <id>//plstyle.cn/</id>
  
  <author>
    <name>Purry</name>
    <email>1034670136@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA-容器介绍</title>
    <link href="//plstyle.cn/2018/10/25/java-collection-map/"/>
    <id>//plstyle.cn/2018/10/25/java-collection-map/</id>
    <published>2018-10-25T04:00:00.000Z</published>
    <updated>2018-11-03T12:19:54.792Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍java中容器相关的内容<br><a id="more"></a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>容器主要包括Collection与Map两种，Collection存储着对象的集合，而Map存储着键值对（两个对象）的映射表。</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="/img/pl/java_collection_view.png" alt=""></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>TreeSet: 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet查找的时间复杂度为O（1），TreeSet则为O(logN)。</li><li>HashSet: 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说是用Iterator遍历HashSet得到的结果是不确定的。</li><li>LinkedHashSet: 具有HashSet的查找效率，且内部使用双向链表维护了元素的插入顺序。</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li>ArrayList: 基于动态数组实现，支持随机访问。</li><li>Vector: 和ArrayList类似，但它是安全的。</li><li>LinkedList: 基于双向链表，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList还可以用作栈、队列和双向队列。</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li>LinkedList: 可以用它来实现双向队列。</li><li>PriorityQueue: 基于堆结构实现，可以用它来实现优先队列。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/img/pl/java_map_view.png" alt=""></p><ul><li>TreeMap: 基于红黑树实现。</li><li>HashMap: 基于哈希表实现。</li><li>HashTable: 和HashMap类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入HashTable并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用ConcurrentHashMap来支持线程安全，并且ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入了分段锁。</li><li>LinkedHashMap: 使用双向链表来维护元素的顺序，顺序为插入顺序或者最少最近（LRU）顺序。</li></ul><h2 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="/img/pl/java_iterator_view.png" alt=""></p><p>Collection实现了Iterator接口，其中的iterator()方法能产生一个Iterator对象，通过这个对象可以遍历迭代Collection中的元素。</p><p>从JDK1.5之后可以使用foreach方法来遍历实现了Iterator接口的聚合对象。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList();</span><br><span class="line"><span class="built_in">list</span>.add(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">list</span>.add(<span class="string">"b"</span>);</span><br><span class="line">for(<span class="built_in">String</span> item: <span class="built_in">list</span>)</span><br><span class="line">   System.out.print(item);</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>java.util.Arrays#asList()可以把数组类型转换为List类似。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SaveVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure><p>应该注意的是asList()的参数为泛型的可变长参数，不能使用基本类型数组作为参数，只能使用对应的包装类型数组。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List <span class="type">list</span> = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一下方式也行</span></span><br><span class="line">List <span class="type">list</span> = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h4><p>实现了RandomAccess接口，因此支持随机访问。这是理所当然，因为ArrayList是基于数组实现的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayList&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractList&lt;E&gt;</span> <span class="title">implements</span> <span class="title">List&lt;E&gt;</span>, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>默认数组大小为10。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="2、扩容"><a href="#2、扩容" class="headerlink" title="2、扩容"></a>2、扩容</h4><p>添加元素的时候使用ensureCapacityInternal()方法来保证容量足够，如果不够时，需要使用grow（）方法进行扩容，新容量的大小为<em>oldCapacity + （oldCapacity &gt;&gt; 1</em>, 也就是就容量的1.5倍。</p><p>扩容操作需要调用Arrays.copyOf()把原素组整个复制到新数组中，这个代价很高，因此最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、删除元素"><a href="#3、删除元素" class="headerlink" title="3、删除元素"></a>3、删除元素</h4><p>需要调用System.arraycopy()将index+1后面的元素都复制到index位置上，该操作的时间复杂度为O（N）,可以看出ArrayList删除元素的代价是非常高的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E remove(<span class="built_in">int</span> <span class="built_in">index</span>) &#123;</span><br><span class="line">    rangeCheck(<span class="built_in">index</span>);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(<span class="built_in">index</span>);</span><br><span class="line">    <span class="built_in">int</span> numMoved = <span class="built_in">size</span> - <span class="built_in">index</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, <span class="built_in">index</span>+<span class="number">1</span>, elementData, <span class="built_in">index</span>, numMoved);</span><br><span class="line">    elementData[--<span class="built_in">size</span>] = null; // clear to let GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、Fail-Fast"><a href="#4、Fail-Fast" class="headerlink" title="4、Fail-Fast"></a>4、Fail-Fast</h4><p>modCount是用来记录ArrayList结构发生变化的次数。结构变化发生是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> element <span class="built_in">count</span>, and <span class="built_in">any</span> hidden stuff</span><br><span class="line">    <span class="built_in">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> <span class="built_in">size</span> as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> <span class="built_in">all</span> elements <span class="keyword">in</span> the proper order.</span><br><span class="line">    for (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount <span class="comment">!= expectedModCount) &#123;</span></span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、序列化"><a href="#5、序列化" class="headerlink" title="5、序列化"></a>5、序列化</h4><p>ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组elementData使用transient修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">Object</span>[] elementData;</span><br></pre></td></tr></table></figure><p>ArrayList实现了writeObject()与readObject()来控制只序列化数组中有元素填充的那部分内容。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(java.io.ObjectInputStream s)</span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Object</span>[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> element <span class="built_in">count</span>, and <span class="built_in">any</span> hidden stuff</span><br><span class="line">    <span class="built_in">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> <span class="built_in">size</span> as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    // <span class="built_in">Write</span> <span class="keyword">out</span> <span class="built_in">all</span> elements <span class="keyword">in</span> the proper order.</span><br><span class="line">    for (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount <span class="comment">!= expectedModCount) &#123;</span></span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>序列化时需要使用ObjectOutputStream的writeObject()将对象转换为字节流并输出。而writeObject()方法在传入的对象存在writeObject()的时候会去反射调用该对象的writeObject()来实现序列化。反序列化使用的是ObjectInputStream的readObject()方法，原理类似。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> <span class="type">ArrayList</span>();</span><br><span class="line">ObjectOutputStram os = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(file));</span><br><span class="line">os.writeObject(list);</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="1、同步"><a href="#1、同步" class="headerlink" title="1、同步"></a>1、同步</h4><p>它的实现与ArrayList类似，但是使用了synchronized进行同步。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">elementData</span><span class="params">(index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、与ArrayList的比较"><a href="#2、与ArrayList的比较" class="headerlink" title="2、与ArrayList的比较"></a>2、与ArrayList的比较</h4><ul><li>Vector是同步的，因此开销比ArrayList要大，访问速度更慢。最好使用ArrayList而不是Vector，因为同步操作完全可以由程序员自己控制。</li><li>Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。</li></ul><h4 id="3、替代方案"><a href="#3、替代方案" class="headerlink" title="3、替代方案"></a>3、替代方案</h4><p>可以使用Collections.synchronizedList();得到一个线程安全的ArrayList。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; synList = Collections.synchronizedList(<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p><p>也可以使用并发包下的CopyOnWriteArrayList类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = <span class="literal">new</span> CopyOnWriteArrayList();</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组上进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">Object</span>[] elements = getArray();</span><br><span class="line">        <span class="built_in">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">Object</span>[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> setArray(<span class="keyword">Object</span>[] a) &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> E <span class="built_in">get</span>(<span class="keyword">Object</span>[] a, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是CopyOnWriteArrayList有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右。</li><li>数组不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以CopyOnWriteArrayList不适合内存敏感以及对实时性要求很高的场景。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="1、概览-1"><a href="#1、概览-1" class="headerlink" title="1、概览"></a>1、概览</h4><p>基于双向链表实现，适用Node存储链表节点信息。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个链表存储了first与last指针：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; first;</span><br><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; last;</span><br></pre></td></tr></table></figure></p><p><img src="/img/pl/java_linkedlist_view.png" alt=""></p><h4 id="2、与ArrayList的比较-1"><a href="#2、与ArrayList的比较-1" class="headerlink" title="2、与ArrayList的比较"></a>2、与ArrayList的比较</h4><ul><li>ArrayList基于动态数组实现，LinkedList基于双向链表实现；</li><li>ArrayList支持随机访问，LinkedList不支持；</li><li>LinkedList在任意位置添加删除元素更快</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="1、存储结构"><a href="#1、存储结构" class="headerlink" title="1、存储结构"></a>1、存储结构</h4><p>内部包含了一个Entry类型的数组table。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry[] <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure><p>Entry存储着键值对。它包含了四个字段，从next字段我们可以看出Entry是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用拉链法来解决冲突，同一个链表中存放哈希值相同的Entry。</p><p><img src="/img/pl/java_hashmap_entrytable.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、拉链法的工作原理"><a href="#2、拉链法的工作原理" class="headerlink" title="2、拉链法的工作原理"></a>2、拉链法的工作原理</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"K1"</span>,<span class="string">"V1"</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"K2"</span>,<span class="string">"V2"</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"K3"</span>,<span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个HashMap,默认大小为16；</li><li>插入&lt;K1,V1&gt;键值对，先计算K1的hashCode为115，使用除留余数法得到所在的下标为115%16=3。</li><li>插入&lt;K2,V2&gt;键值对，先计算K2的hashCode为118，使用除留余数法得到所在的下标为118%16=6。</li><li>插入&lt;K3,V3&gt;键值对，先计算K3的hashCode为118，使用除留余数法得到所在的下标为118%16=6，插在K2前面。</li></ul><p>应该需要注意的是链表的插入是头插法方式进行的，例如上面的&lt;K3,V3&gt;不是插在&lt;K2,V2&gt;后面，而是插在链表的头部。</p><p>查找需要分为两步进行：</p><ul><li>计算键值所在的桶(hashCode % 16)</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><p><img src="/img/pl/java_hashmap_zipper.png" alt=""></p><h4 id="3、put操作"><a href="#3、put操作" class="headerlink" title="3、put操作"></a>3、put操作</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap允许插入键为null的键值对。但是因为无法调用null的hashcode方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap使用第0个桶存放键为null的键值对。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span>(<span class="params">V <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">value</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addEntry(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">int</span> bucketIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">size</span> &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != <span class="built_in">key</span>) ? hash(<span class="built_in">key</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//扩容后需要重新计算下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, <span class="built_in">key</span>, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> createEntry(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">int</span> bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, <span class="built_in">key</span>, value, e);</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entry(<span class="built_in">int</span> h, K k, V v, Entry&lt;K,V&gt; <span class="built_in">n</span>) &#123;</span><br><span class="line">    <span class="built_in">value</span> = v;</span><br><span class="line">    next = <span class="built_in">n</span>;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、确定桶下标"><a href="#4、确定桶下标" class="headerlink" title="4、确定桶下标"></a>4、确定桶下标</h4><p>很多操纵都需要先确定一个键值对所在的桶下标。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int hash</span> = hash(key);</span><br><span class="line"><span class="attribute">int i</span> = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><h5 id="4-1-计算hash值"><a href="#4-1-计算hash值" class="headerlink" title="4.1 计算hash值"></a>4.1 计算hash值</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> k) &#123;</span><br><span class="line">    <span class="built_in">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> <span class="keyword">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((<span class="keyword">String</span>) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-取模"><a href="#4-2-取模" class="headerlink" title="4.2 取模"></a>4.2 取模</h5><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">令 <span class="keyword">x</span> = <span class="number">1</span>&lt;&lt;<span class="number">4</span>，即 <span class="keyword">x</span> 为 <span class="number">2</span> 的 <span class="number">4</span> 次方，它具有以下性质：</span><br><span class="line"></span><br><span class="line"><span class="keyword">x</span>   : <span class="number">00010000</span></span><br><span class="line"><span class="keyword">x</span><span class="number">-1</span> : <span class="number">00001111</span></span><br><span class="line">令一个数 y 与 <span class="keyword">x</span><span class="number">-1</span> 做与运算，可以去除 y 位级表示的第 <span class="number">4</span> 位以上数：</span><br><span class="line"></span><br><span class="line">y       : <span class="number">10110010</span></span><br><span class="line"><span class="keyword">x</span><span class="number">-1</span>     : <span class="number">00001111</span></span><br><span class="line">y&amp;(<span class="keyword">x</span><span class="number">-1</span>) : <span class="number">00000010</span></span><br><span class="line">这个性质和 y 对 <span class="keyword">x</span> 取模效果是一样的：</span><br><span class="line"></span><br><span class="line">y   : <span class="number">10110010</span></span><br><span class="line"><span class="keyword">x</span>   : <span class="number">00010000</span></span><br><span class="line">y<span class="symbol">%x</span> : <span class="number">00000010</span></span><br><span class="line">我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</span><br><span class="line"></span><br><span class="line">确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash<span class="symbol">%capacity</span>，如果能保证 capacity 为 <span class="number">2</span> 的 n 次方，那么就可以将这个操作转换为位运算。</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length<span class="number">-1</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5、扩容-基本原理"><a href="#5、扩容-基本原理" class="headerlink" title="5、扩容-基本原理"></a>5、扩容-基本原理</h4><p>设HashMap的table长度为M,需要存储的键值对数量为N，如果哈希函数满足均匀性要求，那么每条链表的长度大约是N/M,因此平均查找的次数的复杂度为（N/M）。</p><p>为了让查找的复杂度降低，应该尽可能使得N/M尽可能小，因此需要保证M尽可能大，也就是说table要尽可能大。HashMap采用动态扩容来根据当前的N值来调整M值，使得空间效率与时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold和load_factor。</p><ul><li>capacity：table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</li><li>size：table 的实际使用量。</li><li>threshold：size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</li><li>loadFactor：装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</li></ul><p>从下面的元素代码可以看出，当需要扩容时，令capacity为原来的两倍</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>) </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, <span class="keyword">value</span>, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用resize（）实现，需要注意的是，扩容操作同样需要把oldTable的所有键值对重新插入newTable中，因此这一步是很费时的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];</span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、扩容-重新计算桶下标"><a href="#6、扩容-重新计算桶下标" class="headerlink" title="6、扩容-重新计算桶下标"></a>6、扩容-重新计算桶下标</h4><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>假设原数组长度capacity为16，扩容之后new capacity为32：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line"><span class="keyword">new</span> capacity : 00100000</span><br></pre></td></tr></table></figure><p>对于一个key,</p><ul><li>它的哈希值如果第6位上为0，那么取模取模得到的结果和之前是一样的</li><li>如果为1，那么得到的结果为原来的结果+16。</li></ul><h4 id="7、计算数组容量"><a href="#7、计算数组容量" class="headerlink" title="7、计算数组容量"></a>7、计算数组容量</h4><p>HashMap构造函数允许用户传入的容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">先考虑如何求一个数的掩码，对于<span class="number">10010000</span>，它的掩码为<span class="number">11111111</span>，可以使用一下方法得到：</span><br><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>    <span class="number">11011000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>    <span class="number">11111110</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>    <span class="number">11111111</span></span><br><span class="line"></span><br><span class="line">mask+<span class="number">1</span> 是大于原始数字的最小的 <span class="number">2</span> 的 <span class="built_in">n</span> 次方。</span><br><span class="line">num     <span class="number">10010000</span></span><br><span class="line">mask+<span class="number">1</span> <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line">以下是 HashMap 中计算数组容量的代码：</span><br><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、链表转红黑树"><a href="#8、链表转红黑树" class="headerlink" title="8、链表转红黑树"></a>8、链表转红黑树</h4><p>从JDK1.8开始，一个桶存储的链表长度大于8时会将链表转换为红黑树。</p><h4 id="9、与HashTable的比较"><a href="#9、与HashTable的比较" class="headerlink" title="9、与HashTable的比较"></a>9、与HashTable的比较</h4><ul><li>HashTable使用synchronized来进行同步</li><li>HashMap可以插入键为null的Entry</li><li>HashMap的迭代器是fail-fast迭代器</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="1、存储结构-1"><a href="#1、存储结构-1" class="headerlink" title="1、存储结构"></a>1、存储结构</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap和HashMap实现上类似，最主要的差别是ConcurrentHashMap采用的是分段锁（Segment),每个分段锁维护着几个桶（HashEntry),多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是Segment的个数）。</p><p>Segment继承自ReentrantLock。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? 64 : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Segment&lt;K,V&gt;<span class="string">[]</span> segments;</span><br></pre></td></tr></table></figure><p>默认的并发级别为16，也就是说默认创建16个Segment。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/pl/java_concurrenthashmap_segment.png" alt=""></p><h4 id="2、size操作"><a href="#2、size操作" class="headerlink" title="2、size操作"></a>2、size操作</h4><p>每个Segment维护了一个count变量来统计该Segment中的键值对个数。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The <span class="built_in">number</span> <span class="keyword">of</span> elements. Accessed only either within locks</span><br><span class="line"> * <span class="keyword">or</span> among other volatile reads <span class="keyword">that</span> maintain visibility.</span><br><span class="line"> */</span><br><span class="line">transient int <span class="built_in">count</span>;</span><br></pre></td></tr></table></figure><p>在执行size操作时，需要遍历所有Segment然后把count累计起来。</p><p>ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次不加锁得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用RETRIES_BEFORE_LOCK定义，该值为2，retries初始值为-1，因此尝试次数为3。</p><p>如果尝试的次数超过3，那么就需要对每个Segment加锁。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size() &#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">sum</span>;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = <span class="number">-1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">sum</span> = <span class="number">0</span>L;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">sum</span> += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.<span class="keyword">count</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">sum</span> == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = <span class="keyword">sum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、JDK1-8的改动"><a href="#3、JDK1-8的改动" class="headerlink" title="3、JDK1.8的改动"></a>3、JDK1.8的改动</h4><p>JDK1.7使用分段锁机制来实现并发更新操作，核心类为Segment,它继承自重入锁ReentrantLock，并发度与Segment数量相等。</p><p>JDK1.8使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized。</p><p>并且JDK1.8的实现也在链表过长时会转换为红黑树。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>继承自HashMap，因此具有和HashMap一样的快速查找特性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap&lt;K</span>,<span class="title">V&gt;</span> <span class="title">implements</span> <span class="title">Map&lt;K</span>,<span class="title">V&gt;</span></span></span><br></pre></td></tr></table></figure><p>内部维护了一个双向链表，用来维护插入顺序或者LRU顺序。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">transient</span> <span class="selector-tag">LinkedHashMap</span><span class="selector-class">.Entry</span>&lt;<span class="selector-tag">K</span>,<span class="selector-tag">V</span>&gt; <span class="selector-tag">head</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">transient</span> <span class="selector-tag">LinkedHashMap</span><span class="selector-class">.Entry</span>&lt;<span class="selector-tag">K</span>,<span class="selector-tag">V</span>&gt; <span class="selector-tag">tail</span>;</span><br></pre></td></tr></table></figure><p>accessOrder决定了顺序，默认为false，此时维护的是插入顺序。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap最重要的是一下用于维护顺序的函数，它们会在put、get等方法中调用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="aftereNodeAccess"><a href="#aftereNodeAccess" class="headerlink" title="aftereNodeAccess()"></a>aftereNodeAccess()</h4><p>当一个节点被访问时，如果accessOrder为true，则会将该节点移到链表尾部。也就是说指定为LRU顺序之后，在每次访问一个节点时，会将这个节点移动链表尾部，保证链表尾部时最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (<span class="attr">last</span> = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; <span class="attr">p</span> =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="attr">b</span> = p.before, <span class="attr">a</span> = p.after;</span><br><span class="line">        p.<span class="attr">after</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">b</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.<span class="attr">after</span> = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.<span class="attr">before</span> = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="attr">last</span> = b;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">last</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.<span class="attr">before</span> = last;</span><br><span class="line">            last.<span class="attr">after</span> = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">tail</span> = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h4><p>在put等操作之后执行，当removeEldestEntry()方法返回true时会移除最晚的节点，也就是链表首部节点first。</p><p>evict只有在构建Map的时候才为false，在这里为true。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly <span class="built_in">remove</span> eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; <span class="built_in">first</span>;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (<span class="built_in">first</span> = head) != null &amp;&amp; removeEldestEntry(<span class="built_in">first</span>)) &#123;</span><br><span class="line">        K <span class="built_in">key</span> = <span class="built_in">first</span>.<span class="built_in">key</span>;</span><br><span class="line">        removeNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, null, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry()默认为false，如果需要让它为true，只需要继承LinkedHashMap并且覆盖这个方法的实现，这在实现LRU的缓存中特别有用，通过移除最近最久未使用的节点，保证缓存空间足够使用，并且缓存的都是热点数据。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>以下是使用LinkedHashMap实现的一个LRU缓存：</p><ul><li>设定最大缓存空间MAX_ENTRIES为3；</li><li>使用LinkedHashMap的构造函数将accessOrder设置为true,开启LRU顺序；</li><li>覆盖removeEldestEntry()方法实现，在节点多于MAX_ENTRIES就将最近最久未使用的数据移除。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap&lt;K</span>, <span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> int <span class="type">MAX_ENTRIES</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> boolean removeEldestEntry(<span class="type">Map</span>.<span class="type">Entry</span> eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="type">MAX_ENTRIES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LRUCache</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="type">MAX_ENTRIES</span>, <span class="number">0.75</span>f, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    LRUCache&lt;Integer, <span class="keyword">String</span>&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.<span class="built_in">get</span>(<span class="number">1</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(cache.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>WeakHashMap的Entry继承自WeakReference，被WeakReference关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap主要用来实现缓存，通过使用WeakHashMap来引用缓存对象，由jvm对这部分缓存进行回收。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;Object&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="concurrentCache"><a href="#concurrentCache" class="headerlink" title="concurrentCache"></a>concurrentCache</h4><p>Tomcat中的ConcurrentCache使用了WeakHashMap来实现缓存功能。<br>ConcurrentCache采取的是分代缓存：</p><ul><li>经常使用的对象放入eden中，eden使用ConcurrentHashMap实现，不用担心会被回收。</li><li>不常用的对象放入longterm，longterm使用WeakHashMap实现，这些老对象会被垃圾回收器回收</li><li>当调用get()方法时，会先从eden区获取，如果没有找到的话再到longterm获取，当从longterm中获取到就把对象放入eden中，从而保证经常被访问的节点不容易被回收。</li><li>当调用put()方法时，如果eden的大小超过了size，那么就将eden中的所有对象都放入longterm中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="type">K, V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConcurrentCache(int size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = new ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = new WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="keyword">get</span>(K k) &#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.<span class="keyword">get</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.<span class="keyword">get</span>(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void put(K k, V v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍java中容器相关的内容&lt;br&gt;
    
    </summary>
    
    
      <category term="Collection" scheme="//plstyle.cn/tags/Collection/"/>
    
      <category term="Map" scheme="//plstyle.cn/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——中介者模式</title>
    <link href="//plstyle.cn/2018/10/15/blog_pattern_mediator/"/>
    <id>//plstyle.cn/2018/10/15/blog_pattern_mediator/</id>
    <published>2018-10-15T04:00:00.000Z</published>
    <updated>2018-10-30T12:08:22.021Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中中介者模式相关的内容。<br><a id="more"></a></p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>集中相关对象之间复杂的沟通和控制方式。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>Mediator: 中介者，定义一个接口用于与各同事（Colleague）对象沟通。</li><li>Colleague: 同事，相关对象。</li></ul><p><img src="/img/pl/pattern_class_mediator.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Alarm(闹钟)、Coffeepot(咖啡壶)、Calendar(日历)、Sprinkler(喷头)是一种相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p><p><img src="/img/pl/pattern_mediator_implemention1.jpg" alt=""></p><p>使用中介者模式可以将复杂的依赖结构变成星型结构：</p><p><img src="/img/pl/pattern_mediator_implemention2.jpg" alt=""></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Colleague</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onEvent</span>(<span class="params">Mediator mediator</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onEvent(<span class="type">Mediator</span> mediator)&#123;</span><br><span class="line">        mediator.onEvent(<span class="string">"alram"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doAlarm()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"doAlarm()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CoffeePot</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onEvent(<span class="type">Mediator</span> mediator)&#123;</span><br><span class="line">        mediator.onEvent(<span class="string">"coffeePot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doCoffeePot()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"doCoffeePot()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onEvent(<span class="type">Mediator</span> mediator)&#123;</span><br><span class="line">        mediator.onEvent(<span class="string">"calendar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doCalendar()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"doCalendar()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Sprinkler</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onEvent(<span class="type">Mediator</span> mediator)&#123;</span><br><span class="line">        mediator.onEvent(<span class="string">"sprinkler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doSprinkler()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"doSprinkler()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Mediator</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onEvent</span>(<span class="params">String eventType</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Alarm alarm;</span><br><span class="line">    <span class="keyword">private</span> CoffeePor coffeePot;</span><br><span class="line">    <span class="keyword">private</span> Calendar calendar;</span><br><span class="line">    <span class="keyword">private</span> Sprinkler sprinkler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">(Alarm alarm, CoffeePor coffeePor, Calendar calendar, Sprinkler sprinkler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.alarm = alarm;</span><br><span class="line">        <span class="keyword">this</span>.coffeePor = coffeePor;</span><br><span class="line">        <span class="keyword">this</span>.calendar = calendar;</span><br><span class="line">        <span class="keyword">this</span>.sprinkler = sprinkler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(String eventType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(eventType)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"alarm"</span>:</span><br><span class="line">                doAlarmEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"coffeePot"</span>:</span><br><span class="line">                doCoffeePotEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"calendar"</span>:</span><br><span class="line">                doCalendarEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sprinkler"</span>:</span><br><span class="line">               doSprinklerEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAlarmEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        alarm.doAlarm();</span><br><span class="line">        coffeePot.doCoffeePot();</span><br><span class="line">        calendar.doCalendar();</span><br><span class="line">        sprinkler.doSprinkler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCoffeePotEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCalendarEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSprinkler</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> []arr)&#123;</span><br><span class="line">        Alarm alarm = <span class="keyword">new</span> <span class="type">Alarm</span>();</span><br><span class="line">        CoffeePot coffeePot = <span class="keyword">new</span> <span class="type">CoffeePot</span>();</span><br><span class="line">        Calendar calendar = <span class="keyword">new</span> <span class="type">Calendar</span>();</span><br><span class="line">        Sprinkler sprinkler = <span class="keyword">new</span> <span class="type">Sprinkler</span>();</span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> <span class="type">ConcreteMediator</span>(alarm, coffeePot, calendar, sprinkler);</span><br><span class="line">        alarm.onEvent(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果实现</span></span><br><span class="line">doAlarm()</span><br><span class="line">doCoffeePot()</span><br><span class="line">doCalendar()</span><br><span class="line">doSprinkler()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中中介者模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="迭代器模式" scheme="//plstyle.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——迭代器模式</title>
    <link href="//plstyle.cn/2018/10/08/blog_pattern_iterator/"/>
    <id>//plstyle.cn/2018/10/08/blog_pattern_iterator/</id>
    <published>2018-10-08T04:00:00.000Z</published>
    <updated>2018-10-28T04:34:57.077Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中迭代器模式相关的内容。<br><a id="more"></a></p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>Aggregate是聚合类，其中createIterator方法可以产生一个Iterator。</li><li>Iterator主要定义了hasNext（）与next（）方法。</li><li>Client组合了Aggregate，为了迭代遍历Aggregate，也需要组合Iterator。</li></ul><p><img src="/img/pl/pattern_class_iterator.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>Aggregate&#123;</span><br><span class="line">     Iterator createIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] items;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;items.length; i++)&#123;</span><br><span class="line">            items[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;Integer&gt;(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>Iterator&lt;T&gt;&#123;</span><br><span class="line">    T next();</span><br><span class="line"></span><br><span class="line">    boolean hasNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(T[] items)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[position++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] arr</span>)</span>&#123;</span><br><span class="line">        Aggregate aggregate =  <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中迭代器模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="迭代器模式" scheme="//plstyle.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java注解（Annotation）</title>
    <link href="//plstyle.cn/2018/09/27/blog_java_annotation/"/>
    <id>//plstyle.cn/2018/09/27/blog_java_annotation/</id>
    <published>2018-09-27T04:00:00.000Z</published>
    <updated>2018-09-27T02:36:21.184Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要介绍java中的注解（Annotation）的定义以及使用，元注解以及java内置的一些注解，最后就是对注解的使用场景进行介绍。<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java注解用于为java代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java注解从Java5开始添加到java的。</span><br></pre></td></tr></table></figure><p>以上是官方的解释，简单来理解：想象代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解就是一张标签。</p><h2 id="注解语法"><a href="#注解语法" class="headerlink" title="注解语法"></a>注解语法</h2><p>因为平时开发少见，相信有不少的人员会认为注解的地位不高。其实同class与interface一样，注解也是属于一种类型。它是在JavaSE5版本中开始引入的概念。</p><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解通过<em>@interface</em>关键字进行定义</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">TestAnnotation</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>它的形式跟接口很类似，不过前面多了一个@符号。上面的代码就创建了一个名字为TestAnnotation的注解。</p><h3 id="注解的应用"><a href="#注解的应用" class="headerlink" title="注解的应用"></a>注解的应用</h3><p>上面创建了一个注解，那么注解的使用方法是什么呢。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个类Test，然后再类定义的地方加上@TestAnnotation就可以用TestAnnotation注解这个类了。</p><p>你可以简单理解为将TestAnnotation这张标签贴到Test这个类上面。</p><p>不过，要想注解能够正常工作，还需要介绍以下一个新的概念那就是元注解。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解什么意思呢？</p><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>如果难于理解的话，你可以这样理解。元注解也是一种标签，但是它是一种特殊的标签，它的作用和目的就是给其它普通的标签进行解释说明的。</p><p>元标签有@Rentation、@Documented、@Targer、@Inherited、@Repeatable</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>Retention的英文意思为保留期的意思。当@Retention应用到一个注解的时候，它解释说明了这份注解的存活时间。</p><p>它的取值如下:</p><ul><li><p>RetentionPolicy.SOURCE 注解旨在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</p></li><li><p>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，他并不会被加载到JVM中。</p></li><li><p>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们。</p></li></ul><p>我们可以这样的方式来加深理解，@Retention去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention相当于给一张标签盖了一张时间戳，时间戳指明了标签张贴的时间周期。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentationPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> TestAnnotaton&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们指定的TestAnnotation可以在程序运行期间被捕获到，因此它的生命周期非常的长。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>顾名思义，这个元注解肯定时和文档有关，它的作用是能够将注解中的元素包含到javadoc中去。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>Target是目标的意思，@Target指定了注解运用的地方。</p><p>你可以这样理解，当一个注解被@Target注解时，这个注解就被限定了运用的场景了。</p><p>类比标签，原本标签是你想张贴哪个地方就到哪个地方，但是因为@Target的存在，它张贴的地方就非常的具体了，比如只能张贴到方法上、类上、方法参数上等。@Target有下面的取值：</p><ul><li>ElementType.ANNOTATION_TYPE  可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR  可以给构造方法进行注解</li><li>ElementType.FIELD  可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE  可以给局部变量进行注解</li><li>ElementType.METHOD   可以给方法进行注解</li><li>ElementType.PACKAGE  可以给一个包进行注解</li><li>ElementType.PARAMETER  可以给一个方法内的参数进行注解</li><li>ElementType.TYPE  可以给一个类型进行注解，比如类、接口、枚举</li></ul><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>Inherited是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被@Inherited注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Test</span></span><br><span class="line">public class A&#123;&#125;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;&#125;</span><br></pre></td></tr></table></figure><p>注解Test被Inherited修饰，之后类A被Test注解，类B继承类A，类B也拥有Test这个注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>Repeatable自然是可重复的意思。@Repeatable是java1.8才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人既是程序员又是产品经理，同时他还是个画家。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons&#123;</span><br><span class="line">    Person[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    String role() defalut <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Person(role = <span class="meta-string">"artist"</span>)</span></span><br><span class="line"><span class="meta">@Person(role = <span class="meta-string">"coder"</span>)</span></span><br><span class="line"><span class="meta">@Person(role = <span class="meta-string">"PM"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码，@Repeatable注解了Person。而@Repeatable后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方，它本身也是一个注解。</p><p>我们在看看代码中的相关容器注解。</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">Persons</span></span>&#123;</span><br><span class="line">    Person [] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照规定，它里面必须要有一个value的属性，属性类型是一个被Repeatable注解过的注解数组，注意它是数组。</p><p>如果不好理解的话，可以这样理解。Persons是一张总的标签，上面贴满了Person这种同类型但内容不一样的标签。把Persons给一个SuperMan贴上，就相当于同时给他贴上了程序员、产品经理、画家的标签。</p><p>我们可能对于@Person(role=”PM”)括号里面的内容感兴趣，它其实就是给Person这个注解的role属性赋值为PM，大家不明白正常，马上就讲到注解的属性这一块。</p><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以”无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">id</span>();</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">msg</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了TestAnnotation这个注解中拥有id和msg两个属性。在使用的时候，我们应该给它们进行赋值。</p><p>赋值的方式是在注解的括号内以“value=”形式，多个属性之间用“,”隔开。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(id=3,msg=<span class="meta-string">"hello annotation"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在注解中定义属性时它的类型必须是8种基本类型外加类、接口、注解以及它们的数组。</p><p>注解中属性可以有默认值，默认值需要用default关键字指定，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种情况，如果一个注解内仅仅只有一个名字为value的属性时，应用这个注解时可以直接接属性值填写在括号内。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Check</span>(<span class="string">"hi"</span>)</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个等同于上面的写法</span></span><br><span class="line"><span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>最后，还需要注意的一种情况是一个注解没有任何属性。比如</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">Perform</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>那么应用这个注解的时候，连括号都可以省略。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Perform</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Java预置的注解"><a href="#Java预置的注解" class="headerlink" title="Java预置的注解"></a>Java预置的注解</h2><p>学习了上面相关的知识，我们已经可以自己定义一个注解了。其实Java语言本身已经提供了几个现成的注解。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Noting has to say!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"I have a dream!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个Hero类，它有两个方法say与speak，其中say()被@Deprecated注解。然后我们在IDE中分别调用它们。</p><p><img src="/img/pl/annotation_deprecated.png" alt=""></p><p>可以看到，say()方法上面被一条直线划了一条，这其实就是编译器识别后的提醒效果。</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>这个大家应该很熟悉了，提示子类要覆写父类中被@Override修饰的方法</p><h3 id="SuppressWarning"><a href="#SuppressWarning" class="headerlink" title="@SuppressWarning"></a>@SuppressWarning</h3><p>阻止警告的意思。之前说过调用被@Deprecated注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，它们可以在调用的地方通过@SuppressWarning达到目的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">    hero.say();</span><br><span class="line">    hero.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p>参数安全类型注解。它的目的时提醒开发者不要用参数做一些不安全的操作，它的存在会阻止编译器产生unchecked这样的警告。它是在java1.7中加入的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span> <span class="comment">// Not actually safe!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> m(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;... stringLists) &#123;</span><br><span class="line">    <span class="built_in">Object</span>[] array = stringLists;</span><br><span class="line">    <span class="built_in">List</span>&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    array[<span class="number">0</span>] = tmpList; <span class="comment">// Semantically invalid, but compiles without warnings</span></span><br><span class="line">    <span class="built_in">String</span> s = stringLists[<span class="number">0</span>].<span class="keyword">get</span>(<span class="number">0</span>); <span class="comment">// Oh no, ClassCastException at runtime!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，编译阶段不会报错，但是运行时会抛出ClassCastException这个异常，所以它虽然告诉开发者要妥善处理，但是开发者还是搞砸了。</p><p>java官方文档说，未来的版本会授权编译器对这种不去安全的操作产生错误警告。</p><h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p>函数式接口注解，这个是java1.8版本引入的新特性。函数式编程很火，所以java8也及时添加了这个特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行线程开发中常用的Runnable就是一个典型的函数式接口，上面源码可以看到它就是被@FunctionalInterface注解。</p><p>可能有人会疑惑，函数式标记有什么用，这个原因是函数式接口可以很容易转换为Lambda表达式。这是另外的主题了，有兴趣的同学请自己搜索相关的知识点学习。</p><h2 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h2><p>我通过标签来比作注解，前面的内容是讲怎么写注解，然后贴到哪里去，而现在我们要做的工作就是检阅这些注解的内容。形象的比喻就是你把这些注解标签在合适的时候撕下来，然后检阅上面的内容信息。</p><p>要想正确检阅注解，离不开一个手段，那就是反射。</p><h3 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h3><p>注解通过反射获取。首先可以通过Class对象的isAnnotationPresent（）方法判断它是否应用了某个注解。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">boolean</span> isAnnotationPresent(<span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; <span class="title">annotationClass</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过getAnnotation()方法来获取Annotation对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; A getAnnotation(<span class="class"><span class="keyword">Class</span> &lt;<span class="title">A</span>&gt; <span class="title">Annotation</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者getAnnotations()方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前一种方法返回指定类型的注解，后一种方法返回注解到这个元素的所有注解。</span></span><br></pre></td></tr></table></figure><p>如果获取带的Annotation如果不为NULL的话，则就可以调用它们的属性方法了。比如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String []arr)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.<span class="keyword">class</span>.isAnnotationPresent(TestAnnotation.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">if</span>(hasAnnotation)&#123;</span><br><span class="line">            TestAnnotation testAnnotation = Test.<span class="keyword">class</span>.getAnnotation(TestAnnotation.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">            System.out.println(<span class="string">"msg:"</span>+testAnnotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"></span><br><span class="line"><span class="string">id:</span> <span class="number">-1</span></span><br><span class="line"><span class="string">msg:</span></span><br></pre></td></tr></table></figure><p>这个正是TestAnnotation的默认值。</p><p>上面的例子只检阅了注解在类上的注解，其实属性上的注解照样是可以的。同样还是要假手于反射。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@TestAnnotation</span>(msg=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Perform</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test1()&#123;</span><br><span class="line">        Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">        hero.say();</span><br><span class="line">        hero.speak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        boolean hasAnnotation = Test.<span class="keyword">class</span>.isAnnotationPresent(TestAnnotation.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">            TestAnnotation testAnnotation = Test.<span class="keyword">class</span>.getAnnotation(TestAnnotation.<span class="keyword">class</span>);</span><br><span class="line">            <span class="comment">//获取类的注解</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"msg:"</span>+testAnnotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field a = Test.<span class="keyword">class</span>.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            a.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            Check check = a.getAnnotation(Check.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="literal">null</span> ) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"check value:"</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method testMethod = Test.<span class="keyword">class</span>.getDeclaredMethod(<span class="string">"testMethod"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"method testMethod annotation:"</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.<span class="keyword">out</span>.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.<span class="keyword">out</span>.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.<span class="keyword">out</span>.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:-<span class="number">1</span></span><br><span class="line">msg:hello</span><br><span class="line">check value:hi</span><br><span class="line"><span class="function"><span class="keyword">method</span> <span class="title">testMethod</span> <span class="title">annotation</span>:</span>Perform</span><br></pre></td></tr></table></figure><p>需要注意的是，如果一个注解要在运行时被成功提取，那么@Retention(RetentionPolicy.RUNTIME)是必须的。</p><h2 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h2><p>文章开始的时候，我用标签来比作注解。但标签比喻只是我的手段，而不是目的。为的是让大家在初次学习注解时能够不被那些抽象的新概念搞蒙。既然现在，我们对注解有所了解，我们不妨再仔细阅读官方最严谨的文档。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接的影响。</span><br><span class="line">注解有许多用处，主要如下：</span><br><span class="line">-<span class="ruby">提供信息给编译器：编译器可以利用注解来探测错误和警告信息</span></span><br><span class="line"><span class="ruby">-编译阶段时的处理：软件工具可以用来利用注解信息来生成代码、html文档或者做其它相应的处理。</span></span><br><span class="line"><span class="ruby">-运行时处理：某些注解可以再程序运行的时候接受代码的提取。</span></span><br></pre></td></tr></table></figure><p>值得注意的是，注解不是代码本身的一部分。</p><p>如果难于理解，可以这样看。罗永浩永远是罗永浩，不会因为某些人对于他”傻X“的评价而改变，标签只是某些人对于其它事物的评价，但是标签不会改变事物本身，标签只是特定人群的手段。所以，注解同样无法改变代码本身，注解只是某些工具的工具。</p><p>还是回到官方文档的解释上，注解主要针对的是编译器和其它工具软件。</p><p>开发者使用了Annotation修饰了类、方法、Filed等成员后，这些Annotation不会自己生效，必须由开发者提供相应的代码来提取并处理Annotation信息。这些处理提取和处理Anotation的代码统称为APT（Annotation Precessing Tool）。</p><p>现在，我们可以给自己答案了，注解有什么用？给谁用？给编译器或者APT用的。</p><p>以下是自定义的一个注解：<br>我要写一个测试框架，测试程序员的代码有无明显的异常。  </p><ul><li>——程序员 A : 我写了一个类，它的名字叫做 NoBug，因为它所有的方法都没有错误。 </li><li>——我：自信是好事，不过为了防止意外，让我测试一下如何？ </li><li>——程序员 A: 怎么测试？ </li><li>——我：把你写的代码的方法都加上 @Jiecha 这个注解就好了。 </li><li>——程序员 A: 好的。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class NoBug &#123;</span><br><span class="line"></span><br><span class="line">    @Jiecha</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> suanShu()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"1234567890"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Jiecha</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> jiafa()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"1+1="</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Jiecha</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> jiefa()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"1-1="</span>+(<span class="number">1</span><span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    @Jiecha</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> chengfa()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"3 x 5="</span>+ <span class="number">3</span>*<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Jiecha</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> chufa()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"6 / 0="</span>+ <span class="number">6</span> / <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> ziwojieshao()&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"我写的程序没有 bug!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> @interface Jiecha &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class TestTool &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        NoBug testobj = <span class="keyword">new</span> NoBug();</span><br><span class="line"></span><br><span class="line">        Class clazz = testobj.getClass();</span><br><span class="line"></span><br><span class="line">        Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//用来记录测试产生的 log 信息</span></span><br><span class="line">        StringBuilder <span class="built_in">log</span> = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 记录异常的次数</span></span><br><span class="line">        <span class="built_in">int</span> errornum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( Method m: method ) &#123;</span><br><span class="line">            <span class="comment">// 只有被 @Jiecha 标注过的方法才进行测试</span></span><br><span class="line">            <span class="keyword">if</span> ( m.isAnnotationPresent( Jiecha.class )) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    m.invoke(testobj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                    errornum++;</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(m.getName());</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">" "</span>);</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">"has error:"</span>);</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">"\n\r  caused by "</span>);</span><br><span class="line">                    <span class="comment">//记录测试过程中，发生的异常的名称</span></span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(e.getCause().getClass().getSimpleName());</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">"\n\r"</span>);</span><br><span class="line">                    <span class="comment">//记录测试过程中，发生的异常的具体信息</span></span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(e.getCause().getMessage());</span><br><span class="line">                    <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">"\n\r"</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">log</span>.<span class="built_in">append</span>(clazz.getSimpleName());</span><br><span class="line">        <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">" has  "</span>);</span><br><span class="line">        <span class="built_in">log</span>.<span class="built_in">append</span>(errornum);</span><br><span class="line">        <span class="built_in">log</span>.<span class="built_in">append</span>(<span class="string">" error."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成测试报告</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">log</span>.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line"><span class="number">1234567890</span></span><br><span class="line"><span class="number">1</span>+<span class="number">1</span>=<span class="number">11</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span>=<span class="number">0</span></span><br><span class="line"><span class="number">3</span> x <span class="number">5</span>=<span class="number">15</span></span><br><span class="line">chufa has error:</span><br><span class="line"></span><br><span class="line">  caused by ArithmeticException</span><br><span class="line"></span><br><span class="line">/ by zero</span><br><span class="line"></span><br><span class="line">NoBug has  <span class="number">1</span> error.</span><br></pre></td></tr></table></figure><p>结果显示，NoBug这个类是有bug的。</p><p>这样，通过注解我完成了我自己的目的，那就是对别人的代码进行测试。</p><p>所以，再问我注解什么时候用？我只能告诉你，这取决你想用它干什么。</p><h3 id="注解应用实例"><a href="#注解应用实例" class="headerlink" title="注解应用实例"></a>注解应用实例</h3><p>注解运用的地方太多了，因为我是Android开发者，所以我接触到的具体例子有下：</p><h4 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h4><p>JUnit这个是一个测试框架，典型使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleUnitTest</span>&#123;</span></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addition_isCorrect</span><span class="params">()</span> <span class="keyword">throw</span> Exception</span>&#123;</span><br><span class="line">        assertEquals(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Test标记了要进行测试的方法addition_isCorrect()。</p><h4 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h4><p>ButterKnife是Android开发中大名鼎鼎的IOC框架，它减少了大量重复的代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="meta">@BindView</span>(<span class="type">R</span>.id.tv_test)</span><br><span class="line">    <span class="type">TextView</span> mTv;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreated (<span class="type">Bundle</span> savedInstanceState)&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreated(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        <span class="type">ButterKnife</span>.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h4><p>也是一个很有名的依赖注入框架，用于实例对象的生成。</p><h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><p>很牛逼的Http网络访问框架</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>GithubService&#123;</span><br><span class="line">    @<span class="builtin-name">GET</span>(<span class="string">"users/&#123;users&#125;/repos"</span>)</span><br><span class="line">    Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(<span class="string">"user"</span>) Stirng usr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit  retrofit  = new Retrofit.Builder().</span><br><span class="line">                     baseUrl(<span class="string">"http://api.github.com/"</span>)</span><br><span class="line">                     .build();</span><br><span class="line"></span><br><span class="line">GithubService<span class="built_in"> service </span>= retrofit.create(GithubService.class);</span><br></pre></td></tr></table></figure><p>当然还有很多注解应用的地方，这里不一一列举了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1、如果注解难于理解，你就可以把它类同于标签，标签为了解释事物，注解为了解释代码</li><li>2、注解的基本语法，创建如同接口，但是多了个@符号</li><li>3、注解的元注解</li><li>4、注解的属性</li><li>5、注解主要给编译器以及工具类型的软件用的</li><li>6、注解的提取需要借助于java的反射技术，反射比较慢，所以注解使用时需要谨慎计较时间的成本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要介绍java中的注解（Annotation）的定义以及使用，元注解以及java内置的一些注解，最后就是对注解的使用场景进行介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="Annotation" scheme="//plstyle.cn/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——解释器模式</title>
    <link href="//plstyle.cn/2018/09/26/blog_pattern_interpreter/"/>
    <id>//plstyle.cn/2018/09/26/blog_pattern_interpreter/</id>
    <published>2018-09-26T04:00:00.000Z</published>
    <updated>2018-09-26T08:32:56.521Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要介绍设计模式中解释器相关的内容。<br><a id="more"></a></p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>为语言创建解释器，通常由语言的语法以及语法分析来定义</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>TerminalExpression: 终结符表达式，每个终结符都需要一个TerminalExpression.</li><li>Context: 上下文，包含解释器之外的一些全局信息。</li></ul><p><img src="/img/pl/pattern_interpreter_class.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以下是一个规则检验器实现，具有and和or规则，通过规则可以构建一棵解析树，用来检验一个文本是否满足解析树定义的规则。</p><p>例如一棵解析树为D And (A Or (B C))，文本“D A”满足该解析树定义的规则。</p><p>这里Context指的是String。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> interpret(String <span class="keyword">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> literal = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">public <span class="type">TerminalExpression</span>(<span class="type">String</span> str)&#123;</span><br><span class="line">        literal = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean interpret(<span class="type">String</span> str)&#123;</span><br><span class="line">        <span class="type">StringTokenizer</span> st = <span class="keyword">new</span> <span class="type">StringTokenizer</span>(str);</span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreTokens())&#123;</span><br><span class="line">        <span class="type">String</span> test = st.nextToken();</span><br><span class="line">        <span class="keyword">if</span>(test.equal(literal))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Expression</span> expression1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Expression</span> expression2;</span><br><span class="line"></span><br><span class="line">public <span class="type">AndExpression</span>(<span class="type">Expression</span> expression1, <span class="type">Expression</span> expression2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="keyword">this</span>.expression2 = expression2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean interpret(<span class="type">String</span> str)&#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) &amp;&amp; expression2.interpret(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Expression</span> expression1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Expression</span> expression2;</span><br><span class="line"></span><br><span class="line">public <span class="type">OrExpression</span>(<span class="type">Expression</span> expression1, <span class="type">Expression</span> expression2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="keyword">this</span>.expression2 = expression2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean interpret(<span class="type">String</span> str)&#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) || expression2.interprep(str);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clinet</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Expression buildInterpreterTree()&#123;</span><br><span class="line">Expression terminal1 = <span class="keyword">new</span> <span class="type">TerminalExpression</span>(<span class="string">"A"</span>);</span><br><span class="line"></span><br><span class="line">        Expression terminal2 = <span class="keyword">new</span> <span class="type">TerminalExpression</span>(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        Expression terminal3 = <span class="keyword">new</span> <span class="type">TerminalExpression</span>(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">        Expression terminal4 = <span class="keyword">new</span> <span class="type">TerminalExpression</span>(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        Expression alternation1 = <span class="keyword">new</span> <span class="type">OrExpression</span>(terminal2, terminal3);</span><br><span class="line"></span><br><span class="line">        Expression alternation2 = <span class="keyword">new</span> <span class="type">OrExpression</span>(terminal1, alternation1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">AndExpression</span>(terminal4, alternation2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> staic void main(<span class="keyword">String</span>[] arr)&#123;</span><br><span class="line">    Expression define = buildInterpreterTree();</span><br><span class="line">    <span class="keyword">String</span> context1 = <span class="string">"D A"</span>;</span><br><span class="line">    <span class="keyword">String</span> context2 = <span class="string">"A B"</span>;</span><br><span class="line">    System.out.println(define.interpret(context1));</span><br><span class="line">    System.out.println(define.interpret(context2)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要介绍设计模式中解释器相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="解释器模式" scheme="//plstyle.cn/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——命令模式</title>
    <link href="//plstyle.cn/2018/09/20/blog_pattern_command/"/>
    <id>//plstyle.cn/2018/09/20/blog_pattern_command/</id>
    <published>2018-09-20T04:00:00.000Z</published>
    <updated>2018-09-20T06:25:56.146Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中命令模式相关的内容。<br><a id="more"></a></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>命令模式：将一个请求封装为一个对象，从而让我们可以用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为的模式，其别名为动作（Action）模式或（Tansaction）模式。</p><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>命令模式可以将请求发送者与接收者完全解耦，发送者与接收者之间没有直接的引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>命令模式的定义比较复杂，提到了很多的术语，例如“用不同的请求对客户进行参数化”、“对请求进行排队”、”记录请求操作“、”支持可撤销的操作“等，后面我们将对这些术语进行一一讲解。</p><p>命令模式的核心在于引入了命令类，通过命令类来降低发送者与接收者之间的耦合度，请求发送者只需指定一个命令对象，再通过命令对想来调用请求请求接收者的处理方法，类图如下：</p><p><img src="/img/pl/pattern_command_class.jpg" alt=""></p><p>在命令模式结构图中包含如下几个角色：</p><ul><li><p>Command(抽象命令类)：抽象命令类一般是一个接口或者抽象类，其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。</p></li><li><p>ConCreteCommand(具体命令类)：具体命令类是抽象命令类的子类，实现了在抽象命令类种的声明的方法，它对应的具体接收者对象，将接受者的对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作（Action）。<br>h</p></li><li><p>Invoker(调用者)：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现简介调用请求接收者的相关操作。</p></li><li><p>Receiver(接收者对象)：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行对应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令模式的关键在于引入了抽象命令者，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令擦与接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute方法，每一个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，在不同的具体命令提供了execute()方法的不同实现并调用不同的接收者的请求处理方法。</p><p>典型的抽象命令行代码如下所示：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于请求发送者即调用者而言，将针对抽象命令类进行编程，可以通过构造注入或者设值注入的方式在运行时传入具体命令类对象，并在业务方法中调用命令对象的execute()方法，其典型代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span>&#123;</span></span><br><span class="line">     <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//构造注入</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.command = command;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设值注入</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.command = command;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//业务方法，用于调用命令类的exexute()方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">     command.execute();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中的execute（）方法，并在实现时调用接收者的请求响应方法action（）,其典型代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Receiver</span> receiver;  <span class="comment">//维持一个对请求接收者对象的引用, 可以用构造注入或者设值注入</span></span><br><span class="line"></span><br><span class="line">public void execute()&#123;</span><br><span class="line">receiver.action();<span class="comment">//调用请求接受者的业务处理方法action（）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求接收者Receiver类具体实现对请求的业务处理，它提供了action()方法，用于执行与请求相关的操作，其典型代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>命令模式是一种使用频率非常高的设计模式，它可以将请求者与发送者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好得灵活性和可扩展性。在基于GUI的软件开发中，无论是电脑桌面应用还是移动应用中，命令模式都得到了广泛的运用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>命令模式的主要优点如下：</p><ul><li><p>降低系统的耦合度。由于请求者与接收者之间不存在直接应用的关系，因此请求者与接收者之间实现完全解耦，相同的请求则可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</p></li><li><p>新的命令可以很容易地添加到系统中。由于添加新的具体命令类不会影响到其它类，因此添加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</p></li><li><p>可以比较容易地设计一个命令队列或者宏命令（组合命令）。</p></li><li><p>为请求的撤销以及恢复操作提供了一种设计和实现方案。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此，在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>以下情况下可以考虑使用命令模式：</p><ul><li><p>系统需要将请求调用者与请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</p></li><li><p>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者已经不在了，而命令对象本身仍然还是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用的存在性，可以通过请求日志文件等机制来具体实现。</p></li><li><p>系统需要支持命令的撤销以及恢复操作</p></li><li><p>系统需要将一组操作组合在一起形成一组宏命令。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中命令模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="命令模式" scheme="//plstyle.cn/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="//plstyle.cn/2018/09/11/blog_pattern_chain_of_responsibility/"/>
    <id>//plstyle.cn/2018/09/11/blog_pattern_chain_of_responsibility/</id>
    <published>2018-09-11T04:00:00.000Z</published>
    <updated>2018-09-11T06:34:08.873Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中责任链模式相关的内容。<br><a id="more"></a></p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>Handler: 定义处理请求的接口，并且实现后继链（successor）</li></ul><p><img src="/img/pl/pattern_chain_of_responsibility_class.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Handler successor</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span>(<span class="params">Request request</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    public <span class="type">ConcreteHandler1</span>(<span class="type">Handler</span> succossor)&#123;</span><br><span class="line">        <span class="keyword">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrride</span></span><br><span class="line">    <span class="keyword">protected</span> void handlerRequest(<span class="type">Request</span> request)&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.getTpye() == <span class="type">RequestType</span>.<span class="type">TYPE1</span>)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(request.getName() + <span class="string">" is handle by ConcreteHandler1"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(successor != <span class="literal">null</span>)&#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    public <span class="type">ConcreteHandler2</span>(<span class="type">Handler</span> succossor)&#123;</span><br><span class="line">        <span class="keyword">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrride</span></span><br><span class="line">    <span class="keyword">protected</span> void handlerRequest(<span class="type">Request</span> request)&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.getTpye() == <span class="type">RequestType</span>.<span class="type">TYPE2</span>)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(request.getName() + <span class="string">" is handle by ConcreteHandler2"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(successor != <span class="literal">null</span>)&#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RequestType requestType;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Request(RequestType requestType, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestType = requestType;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RequestType getType()&#123;</span><br><span class="line">        <span class="keyword">return</span> requestType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">RequestType</span>&#123;</span></span><br><span class="line">    TYPE1,TYPE2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] arg)&#123;</span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> <span class="type">ConcreteHandler1</span>(<span class="literal">null</span>);</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> <span class="type">ConcreteHandler2</span>(handler1);</span><br><span class="line"></span><br><span class="line">        Request request1 = <span class="keyword">new</span> <span class="type">Request</span>(RequestType.TYPE1, <span class="string">"request1"</span>);</span><br><span class="line">        handler2.handleRequest(request1);</span><br><span class="line"></span><br><span class="line">        Request request2 = <span class="keyword">new</span> <span class="type">Request</span>(RequestType.TYPE2, <span class="string">"request2"</span>);</span><br><span class="line">        handler2.handleRequest(request2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request1 <span class="keyword">is</span> handle <span class="keyword">by</span> ConcreteHandler1</span><br><span class="line">request2 <span class="keyword">is</span> handle <span class="keyword">by</span> ConcreteHandler2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中责任链模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="责任链模式" scheme="//plstyle.cn/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——桥接模式</title>
    <link href="//plstyle.cn/2018/09/07/blog_pattern_bridge/"/>
    <id>//plstyle.cn/2018/09/07/blog_pattern_bridge/</id>
    <published>2018-09-07T04:00:00.000Z</published>
    <updated>2018-09-07T07:33:20.239Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中桥接模式相关的内容。<br><a id="more"></a></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将抽象与实现分离开来，使他们可以独立变化。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>Abstraction：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><img src="/img/pl/pattern_bridge_class.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>RemoteControl表示遥控器，指代Abstraction。</p><p>TV代表电视，指代Implementor。</p><p>桥接模式把电视机与遥控器分离开来，从而可以独立改变遥控器或者电视机的实现。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">TV</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span>(<span class="params"></span>)</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sony</span> <span class="keyword">extends</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony.on()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony.off()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sony.tuneChannel()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RCA</span> <span class="keyword">extends</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RCA.on()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RCA.off()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RCA.tuneChannel()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span>(<span class="params">TV tv</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">on</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">off</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">tuneChannel</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemoteControl1</span> <span class="keyword">extends</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemoteControl1</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1.on()"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1.off()"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl1.tuneChannel()"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteRemoteControl2</span> <span class="keyword">extends</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteRemoteControl2</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2.on()"</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2.off()"</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tuneChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConcreteRemoteControl2.tuneChannel()"</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        RemoteControl remoteControl1 = <span class="keyword">new</span> ConcreteRemoteControl1(<span class="keyword">new</span> RCA());</span><br><span class="line">        remoteControl1.<span class="keyword">on</span>();</span><br><span class="line">        remoteControl1.off();</span><br><span class="line">        remoteControl1.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中桥接模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="桥接模式" scheme="//plstyle.cn/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——原型模式</title>
    <link href="//plstyle.cn/2018/09/04/blog_pattern_propotype/"/>
    <id>//plstyle.cn/2018/09/04/blog_pattern_propotype/</id>
    <published>2018-09-04T04:00:00.000Z</published>
    <updated>2018-09-04T02:08:13.615Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍设计模式中原型模式相关的内容。<br><a id="more"></a></p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使用原型实例指定要创建的对象类型，通过复制这个原型来创建新对象。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/pl/pattern_propotype_class.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Propotype</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Propotype <span class="title">myClone</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcretePropotype</span> <span class="keyword">extends</span> <span class="title">Propotype</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">String</span> field;</span><br><span class="line"></span><br><span class="line">     public <span class="type">ConcretePropotype</span>(<span class="type">String</span> field)&#123;</span><br><span class="line">          <span class="keyword">this</span>.field = field;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     public <span class="type">Propotype</span> myClone()&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ConcretePropotype</span>(field);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     public <span class="type">String</span> toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span>(<span class="params">String[] arr</span>)</span>&#123;</span><br><span class="line">        Propotype propotype = <span class="keyword">new</span> ConcretePropotype(<span class="string">"abc"</span>);</span><br><span class="line">        Propotype clone = propotype.myClone();</span><br><span class="line">        System.<span class="keyword">out</span>.print(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">abc</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍设计模式中原型模式相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="原型模式" scheme="//plstyle.cn/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的HTTP请求</title>
    <link href="//plstyle.cn/2018/09/03/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82/"/>
    <id>//plstyle.cn/2018/09/03/一次完整的http请求/</id>
    <published>2018-09-03T04:00:00.000Z</published>
    <updated>2018-09-03T09:20:13.660Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍一次完整的http请求需要的7个步骤<br><a id="more"></a></p><h2 id="一次完整的Http请求需要的7个步骤"><a href="#一次完整的Http请求需要的7个步骤" class="headerlink" title="一次完整的Http请求需要的7个步骤"></a>一次完整的Http请求需要的7个步骤</h2><h3 id="1、建立Tcp链接"><a href="#1、建立Tcp链接" class="headerlink" title="1、建立Tcp链接"></a>1、建立Tcp链接</h3><p>在Http开始工作之前，客户端首先需要通过网络与服务器进行连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有底层协议建立之后，才能进行更高层协议的连接，因此首先要建立TCP连接，一般TCP连接的默认端口是80。</p><h3 id="2、客户端向服务器发送请求命令"><a href="#2、客户端向服务器发送请求命令" class="headerlink" title="2、客户端向服务器发送请求命令"></a>2、客户端向服务器发送请求命令</h3><p>一旦建立了TCP连接，客户端就会向服务器发送请求命令</p><h3 id="3、客户端发送请求头信息"><a href="#3、客户端发送请求头信息" class="headerlink" title="3、客户端发送请求头信息"></a>3、客户端发送请求头信息</h3><p>客户端发送请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后再发送一空白行告知服务器，它已经结束了该头信息的发送。</p><h3 id="4、服务器应答"><a href="#4、服务器应答" class="headerlink" title="4、服务器应答"></a>4、服务器应答</h3><p>客户端向服务器发出请求之后，服务器会对客户端回送应答，HTTP/1.1  200 OK，应答的第一部分是协议版本号以及应答状态码。</p><h3 id="5、服务器发送应答头信息"><a href="#5、服务器发送应答头信息" class="headerlink" title="5、服务器发送应答头信息"></a>5、服务器发送应答头信息</h3><p>正如客户端会随同请求发送自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据以及被请求的文档。</p><h3 id="6、服务器向客户端发送数据"><a href="#6、服务器向客户端发送数据" class="headerlink" title="6、服务器向客户端发送数据"></a>6、服务器向客户端发送数据</h3><p>服务器向客户端发送头消息后，它会发送一个空白行来表示头信息的发送到此为止，接着，它以Content-Type应答信息所描述的格式发送用户请求的格式（json、xml等）</p><h3 id="7、服务器关闭TCP连接"><a href="#7、服务器关闭TCP连接" class="headerlink" title="7、服务器关闭TCP连接"></a>7、服务器关闭TCP连接</h3><p>一般情况下，一旦服务器向客户端发送了请求数据，它就要关闭TCP连接，然后如果客户端或者服务器在头信息中加入了这行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure><p>TCP连接在发送后仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个连接建立新连接所需的时间，还节约了宽带。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍一次完整的http请求需要的7个步骤&lt;br&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="//plstyle.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>View的过度绘制简述</title>
    <link href="//plstyle.cn/2018/09/03/blog_view_overdraw/"/>
    <id>//plstyle.cn/2018/09/03/blog_view_overdraw/</id>
    <published>2018-09-03T04:00:00.000Z</published>
    <updated>2018-09-03T07:16:12.824Z</updated>
    
    <content type="html"><![CDATA[<hr><p>简要介绍Android中View的过度绘制以及常用的检测方法与防范<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>话不多说，先来两张图：</p><p>图一：<br><img src="/img/pl/view_overdraw_demo1.jpg" alt=""></p><p>图二：</p><p><img src="/img/pl/view_overdraw_demo2.jpg" alt=""></p><p>以上两张是通过Android手机的<em>调试GPU过度绘制</em>功能显示的两个不同的应用检测界面，颜色越红说明过度绘制越严重。第一张以绿色与蓝色居多，还算OK；而第二张则是粉红色甚至红色为主，说明过度绘制比较严重。</p><h3 id="什么是过度绘制"><a href="#什么是过度绘制" class="headerlink" title="什么是过度绘制"></a>什么是过度绘制</h3><p>过度绘制描述的是屏幕上的某个像素点在同一帧的时间内被绘制了多次。在多层的UI结构里面，如果不可见的UI也在做绘制操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的CPU与GPU资源，绘制示意图如下展示：</p><p><img src="/img/pl/view_overdraw_invilate.png" alt=""></p><p>这里可以看出是一层层绘制，搞清楚过度绘制之前，还是先了解Android的渲染机制吧。</p><h3 id="Android渲染机制"><a href="#Android渲染机制" class="headerlink" title="Android渲染机制"></a>Android渲染机制</h3><h4 id="1、Android如何将代码渲染到手机屏幕上"><a href="#1、Android如何将代码渲染到手机屏幕上" class="headerlink" title="1、Android如何将代码渲染到手机屏幕上"></a>1、Android如何将代码渲染到手机屏幕上</h4><p>我们知道手机是由许多像素点构成的通过显示每个像素点不同的颜色，然后组成各种图像；Activity的界面之所以可以被绘制到屏幕上其中有一个很重要的过程就是栅格化，栅格化简单来说就是将向量图转化为机器可以识别的位图的过程，其中很复杂也很耗时。</p><p>GPU就是用来加速栅格化的过程的，下面用一张图来介绍下大致的渲染过程：</p><p><img src="/img/pl/view_overdraw_resterization.jpg" alt=""></p><p>从上面的图可以看出，CPU会先把UI组件计算成polygons(多边形)和texture(纹理)，然后再交给GPU栅格化渲染，最后GPU再将数据传递给屏幕，有屏幕进行绘制显示。当然，从CPU到GPU还需要进行Opengl ES的处理，这也是很复杂的一个过程。</p><p>因此我们可以看出android的渲染依赖两个核心组件：</p><ul><li>CPU：负责Messure、Layout、Record以及Execute等计算操作（容易产生不必要的重绘）</li><li>GPU：负责Rasterization（栅格化）操作（容易产生过度绘制问题）</li></ul><p>在GPU方面，最常见的问题就是我们所说的过度绘制，通常是在像素着色过程中，通过其它工具进行后期着色时浪费了GPU的处理时间。</p><h4 id="2、手机像素点数据哪里来？Frame-Buffer和Back-Buffer"><a href="#2、手机像素点数据哪里来？Frame-Buffer和Back-Buffer" class="headerlink" title="2、手机像素点数据哪里来？Frame Buffer和Back Buffer"></a>2、手机像素点数据哪里来？Frame Buffer和Back Buffer</h4><p>手机屏幕是由许多的像素点组成的，通过让每一个屏幕显示不同的颜色，可以组合成各种各样的图像。这些像素点的颜色是从哪里来的？</p><p>GPU控制的一块缓冲区，这块缓冲区叫做Frame Buffer(也就是帧缓冲区)。你可以把它理解成一个二维数组，数组中每一个元素对应着手机屏幕的一个像素点，元素的值代表着屏幕上对应的像素点要显示的颜色。优化屏幕画面不断变化，需要这个Buffer不断的更新数据，一个FrameBuffer肯定是应接不暇的，因此GPU除了Frame Buffer，用以交给手机屏幕进行绘制外，还有一个缓冲区，叫Back Buffer，这个Back Buffer用以交给你得应用，让你往里面填充数据。GPU会定期交换Back Buffer与Frame Buffer，也就是让Back Buffer变成Frame Buffer交给屏幕进行绘制，让Frame Buffer变成Back Buffer交给你得应用进行绘制。交换的频率是60次/s，这就与屏幕硬件电路的刷新频率保持了同步。如下图所示：</p><p><img src="/img/pl/view_overdraw_buffer.png" alt=""></p><p>关于缓冲机制如双缓冲、三缓冲这里就不进行介绍了，有兴趣的可以自行查阅资料。</p><h4 id="3、关于VSync"><a href="#3、关于VSync" class="headerlink" title="3、关于VSync"></a>3、关于VSync</h4><p>刷新屏幕的时机就由VSync信号来控制，由于人眼与大脑的协作无法感知超过60fps的画面更新，因此需要在16ms内完成屏幕刷新的所有逻辑，否则就会出现画面丢失造成卡顿。</p><p>VSync(Vertical Synchronization)，就是所谓的垂直同步。在Android也沿用了这个概念，我们也可以把它理解为”帧同步”。这个用保证CPU、GPU生成帧的速度与display刷新的速度保持一致。Android系统每16ms就会发出VSync信号触发UI渲染更新。上面提到屏幕一秒刷新60次，这就要求CPU与GPU每秒要有处理60帧的能力，一帧花费的时间在16ms内。那么在Android系统中是如何利用VSYNC进行工作的呢？如下图</p><p><img src="/img/pl/view_overdraw_vsync.jpg" alt=""></p><p>设计预期是这样的一个过程：在VSYNC信号刚发出时，Android系统就立刻开始了下一帧数据的处理了，这样就不会浪费时间了。图中先显示第0帧，在这16ms内，CPU与GPU已经开始准备下一帧的数据了，赶在下一个VSYNC信号到来时，GPU渲染完成，及时交换数据，display绘制显示完成，每一帧如果可以井然有序的进行，那么用户就不会感到卡顿了，看起来很美妙，难道不是吗？</p><h2 id="过度绘制的检测与防范"><a href="#过度绘制的检测与防范" class="headerlink" title="过度绘制的检测与防范"></a>过度绘制的检测与防范</h2><p>通过上面的一些理论学习，我们更好了解了关于过度绘制的一些细节，下面将来介绍以下如何解决过度绘制的常见工具和套路。</p><h3 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h3><h4 id="手机检测工具"><a href="#手机检测工具" class="headerlink" title="手机检测工具"></a>手机检测工具</h4><p>按照以下步骤打开Show GPU Overdraw的选项：设置——&gt;开发者选项——&gt;调试GPU过度绘制——&gt;显示GPU过度绘制。</p><p>每个颜色的说明如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原色：没有过度绘制</span><br><span class="line">蓝色：<span class="number">1</span> 次过度绘制</span><br><span class="line">绿色：<span class="number">2</span> 次过度绘制</span><br><span class="line">粉色：<span class="number">3</span> 次过度绘制</span><br><span class="line">红色：<span class="number">4</span> 次及以上过度绘制</span><br></pre></td></tr></table></figure><p>过度绘制的存在会导致界面显示时浪费不必要的资源去渲染看不见的背景，或者对某些像素区域进行多次绘制，就会导致界面加载或者滑动时的不流畅、掉帧，对于用户来说就是App特别的卡顿。为了提升用户体验，提升应用的流畅性，优化过度绘制的工作还是很有必要的。</p><h4 id="Android-Studio检测工具"><a href="#Android-Studio检测工具" class="headerlink" title="Android Studio检测工具"></a>Android Studio检测工具</h4><p>打开步骤：Tools-&gt; Android -&gt; Android Device Monitor，如下图：</p><p><img src="/img/pl/view_overdraw_monitor.png" alt=""></p><h4 id="HierarchyViewer"><a href="#HierarchyViewer" class="headerlink" title="HierarchyViewer"></a>HierarchyViewer</h4><p>进行UI布局复杂程度及冗余等分析，要使用这个工具需要在虚拟机上才能work，不然会报</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unbale <span class="keyword">to</span> <span class="builtin-name">get</span> view<span class="built_in"> server </span>version <span class="keyword">from</span> device</span><br></pre></td></tr></table></figure><p>如果需要真机使用这个功能Android SDK开发团队提供了ViewServer这个开源库，项目地址<a href="https://github.com/romainguy/ViewServer，需要在Activity的onCreate、onDestroy以及onResume这三个方法中调用ViewServer的对应的方法即可在真机环境下使用HierarchyViewer工具。" target="_blank" rel="noopener">https://github.com/romainguy/ViewServer，需要在Activity的onCreate、onDestroy以及onResume这三个方法中调用ViewServer的对应的方法即可在真机环境下使用HierarchyViewer工具。</a></p><h4 id="布局分析器"><a href="#布局分析器" class="headerlink" title="布局分析器"></a>布局分析器</h4><p><img src="/img/pl/view_overdraw_layoutparse1.png" alt=""></p><p>这个工具通常也可以分析别人app UI的实现，非常强大</p><p><img src="/img/pl/view_overdraw_layoutparse2.png" alt=""></p><p>你可以查看当前UI截图的任意控件，比如觉得图片那块过度绘制这么严重，点击看一下，可以看到对应的布局、资源ID，全局查找一下，就可以到对应的位置去看看代码，这样就可以通过可视化快速定位到问题代码，进行修复。</p><h3 id="防范套路"><a href="#防范套路" class="headerlink" title="防范套路"></a>防范套路</h3><p>通过以上的工具找到问题后就是如何去处理了，下面总结了一些常用的套路。</p><h4 id="套路一、去掉window的默认背景"><a href="#套路一、去掉window的默认背景" class="headerlink" title="套路一、去掉window的默认背景"></a>套路一、去掉window的默认背景</h4><p>当我们使用Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局又添加了一张背景图或者设置了背景色，那么DecorView的background对我们来说是无用的，但是它会产生一次overdraw，带来绘制性能消耗。去掉window背景可以在onCreate（）的setContentView（）之前调用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">getWindow</span>()<span class="selector-class">.setBackgroundDrawable</span>(null);</span><br></pre></td></tr></table></figure><p>或者在theme中添加</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android:windowground </span>= <span class="string">"null"</span></span><br></pre></td></tr></table></figure><h4 id="套路二、去掉其它不必要的背景"><a href="#套路二、去掉其它不必要的背景" class="headerlink" title="套路二、去掉其它不必要的背景"></a>套路二、去掉其它不必要的背景</h4><p>有时候为了方便会给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度为match_parent，可以看到完全覆盖了Layout的一部分，这里可以通过分别绘制背景来减少重绘。再比如如果设置的是seletor的背景，将normal状态的color设置为“@android:color/transparent”，也同样可以解决问题。这里只简单的举了两个例子，我们在开发过程中的一些习惯性的思维定式会带来不经意的过度绘制，所以开发过程中我们为某个View或者ViewGroup设置背景时，先考虑下是否真的有必要，或者想下这个背景能否分段设置在子View上，而不是图方便直接设置在根View上。</p><h4 id="套路三、clipRect的使用"><a href="#套路三、clipRect的使用" class="headerlink" title="套路三、clipRect的使用"></a>套路三、clipRect的使用</h4><p>我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一个矩形区域，只有在一个区域内才会被绘制，其它区域会被忽略。这个api可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU的资源，在clipRect区域之外的绘制指令都不会被执行，那些部分区域在矩形区域内的组件，仍然会得到绘制。</p><h4 id="套路四、ViewStup"><a href="#套路四、ViewStup" class="headerlink" title="套路四、ViewStup"></a>套路四、ViewStup</h4><p>ViewStup称之为延迟化加载，在多数情况下，程序无需显示的指示ViewStup所指向的布局文件，只有在特定的，某些较少的条件下，此时ViewStup所指向的布局文件才需要被inflate，且此布局文件直接在当前ViewStup替换掉，具体是通过ViewStup.inflate()或者ViewStup.setVisibility(View.VISIBLE)来设置的；常见的比如网络加载布局。</p><h4 id="套路五、Merge标签"><a href="#套路五、Merge标签" class="headerlink" title="套路五、Merge标签"></a>套路五、Merge标签</h4><p>Merge标签可以干掉一个层级。Merge的作用很明显，但是也有一些使用条件的限制。有两种条件我们可以使用Merge标签来做容器控件。第一种子视图不需要指定任何针对父布局的属性，就是说父容器仅仅就是个容器，子视图只需添加到父视图上用于显示就行了。另外一种是加入需要在LinearLayout中嵌入一个布局，而恰恰这个布局的根节点也是LinearLayout，这样就多了一层没用的嵌套，无疑这样就会拖慢程序速度。而这个时候我们使用Merge标签就可以避免那样的问题。另外merge只能作为xml的根标签使用，当inflate以开头的布局文件时，必须指定一个父ViewGroup，并且设置attachRoot为true。不常用的UI被设置成GONE，比如异常的错误页面，如果有这类问题，我们需要使用标签，代替GONE提高UI性能。毕竟View的VISIBLE/GONE是会引起布局重绘的。</p><h4 id="套路六、include标签"><a href="#套路六、include标签" class="headerlink" title="套路六、include标签"></a>套路六、include标签</h4><p>include标签能够重用布局。</p><p>还可以尝试使用RelativeLayout以及ConstraintLayout来减少布局的嵌套，提高UI性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事情虽小，也不是什么大的难点，但是这个背后的牵涉的面还是很广的，还是值得去总结总结，有助于以点到面的构建自己的知识体系。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">http://hukai.me/android-performance-patterns/</a></li><li><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE</a></li><li><a href="https://developer.android.com/studio/profile/dev-options-overdraw.html" target="_blank" rel="noopener">https://developer.android.com/studio/profile/dev-options-overdraw.html</a></li><li><a href="http://www.jianshu.com/p/a769a6028e51" target="_blank" rel="noopener">http://www.jianshu.com/p/a769a6028e51</a></li><li><a href="http://blog.csdn.net/yanbober/article/details/48394201" target="_blank" rel="noopener">http://blog.csdn.net/yanbober/article/details/48394201</a></li><li><a href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2.html" target="_blank" rel="noopener">http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2.html</a></li><li><a href="http://blog.csdn.net/xyz_lmn/article/details/14524567" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/article/details/14524567</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;简要介绍Android中View的过度绘制以及常用的检测方法与防范&lt;br&gt;
    
    </summary>
    
    
      <category term="过度绘制" scheme="//plstyle.cn/tags/%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>java并发简述</title>
    <link href="//plstyle.cn/2018/08/30/blog_concurrence/"/>
    <id>//plstyle.cn/2018/08/30/blog_concurrence/</id>
    <published>2018-08-30T04:00:00.000Z</published>
    <updated>2018-08-31T08:17:39.576Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍java中并发相关的线程（Thread）、线程池、线程同步以及协作、java内存模型以及锁相关的内容。<br><a id="more"></a></p><h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>介绍java中并发相关的线程（Thread）、线程池、线程同步以及协作、java内存模型以及锁相关的内容。</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul><li>并发的实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用，并发性是对有限物理资源强制行使 多用户共享以提高效率。</li><li>并行指两个或两个以上事件或活动在同一时刻发生，在多道程序环境下，并行使多个程序同一时刻可在不同CPU上同时执行。    </li><li>并发是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为CPU要在多个程序之间切换）运行多个程序。</li><li>并行是每一个CPU运行一个程序。</li></ul><h2 id="二、线程状态切换"><a href="#二、线程状态切换" class="headerlink" title="二、线程状态切换"></a>二、线程状态切换</h2><p><img src="/img/pl/concurrence_thread_status.png" alt=""></p><p>如图所示，分为多个状态，接下来会一一介绍。</p><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>创建后尚未启动</p><h3 id="可运行"><a href="#可运行" class="headerlink" title="可运行"></a>可运行</h3><p>可能正在运行，也可能正在等待时间CPU时间，包含了操作系统线程状态中的Running以及Ready。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>等待获取一个排它锁，如果其它线程释放了锁就会结束此状态。</p><h3 id="无限期等待"><a href="#无限期等待" class="headerlink" title="无限期等待"></a>无限期等待</h3><p>等待其它线程显示地唤醒，否则不会被分配时间片。</p><h4 id="进入方法与退出方法"><a href="#进入方法与退出方法" class="headerlink" title="进入方法与退出方法"></a>进入方法与退出方法</h4><ul><li>没有设置Timeout参数的Object.wait()方法—————Object.notify() / Object.notifyAll()</li><li>没有设置Timeout参数的Thread.join()方法—————被调用的线程执行完毕</li><li>LockSupport.park()方法————          -</li></ul><h3 id="限期等待"><a href="#限期等待" class="headerlink" title="限期等待"></a>限期等待</h3><p>无需等待其它线程显示地唤醒，在一定时间后会被系统自动唤醒。</p><p>调用Thread.sleep()方法使线程进入限期等待的状态，常常“使一个线程睡眠”进行描述。</p><p>调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠与挂起是用来描述行为，而阻塞与等待是用来描述状态的。</p><p>阻塞与等待的区别在于，阻塞是被动的，它是在等待一个排它锁。而等待是主动的，通过调用Thread.sleep()或者Object.wait()等方法进入。</p><h4 id="进入方法与退出方法-1"><a href="#进入方法与退出方法-1" class="headerlink" title="进入方法与退出方法"></a>进入方法与退出方法</h4><ul><li>Thread.sleep()方法————时间</li><li>设置了Timeout参数的Object.wait()方法————时间结束或者Object.notify()或者Object.notifyAll()。</li><li>设置了Timeout参数的Thread.join()方法————时间结束或者被调用的线程执行完毕</li><li>LockSupport.parkNanos() 方法————               -</li><li>LockSupport.parkUntil() 方法————               -</li></ul><h3 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h3><p>可以是线程结束任务后自己结束或者产生了异常而结束。</p><h2 id="三、使用线程"><a href="#三、使用线程" class="headerlink" title="三、使用线程"></a>三、使用线程</h2><p>有三种使用线程的方法：</p><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li></ul><p>实现Runnable与Callable接口的类只能当作一个可以在线程中执行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以说任务是通过线程驱动来执行的。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现run方法，通过Thread调用start()方法来启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public<span class="keyword"> static</span> void main(String[] args) &#123;</span><br><span class="line">    MyRunnable<span class="built_in"> instance </span>=<span class="built_in"> new </span>MyRunnable();</span><br><span class="line">    Thread thread =<span class="built_in"> new </span>Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> <span class="type">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> <span class="type">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.<span class="keyword">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>同样也是需要实现run()方法，因为Thread类也实现了Runnable接口，当调用一个start()方法启动一个线程，虚拟机会讲该线程放入就绪队列等待被调度，当一个线程被调度时就会执行run()方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口-VS-继承Thread类"><a href="#实现接口-VS-继承Thread类" class="headerlink" title="实现接口 VS 继承Thread类"></a>实现接口 VS 继承Thread类</h3><p>实现接口会更好些，因为：</p><ul><li>java不支持多继承，因此继承了Thread类就无法继承其它类，但是可以实现多个接口</li><li>类可能只要求可执行就行，继承整个Thread类开销过大。</li></ul><h2 id="四、基础线程机制"><a href="#四、基础线程机制" class="headerlink" title="四、基础线程机制"></a>四、基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor管理多个异步任务的执行，而无需程序员显示的管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。主要有三种Executor：</p><ul><li>CacheThreadPool: 一个任务创建一个线程</li><li>FixedThreadPool: 所有的任务只能使用固定大小的线程</li><li>SingleThreadExecutor：相当于大小为1的FixedThreadPool</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。当所有的非守护线程结束时，程序也就终止了，同时会杀死所有的守护线程。main()属于非守护进程，使用setDaemon()方法将一个线程设置为守护线程。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] arg)&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">MyRunnable</span>());</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec)方法会休眠当前正在执行的线程，millisec单位为毫秒</p><p>sleep()方法可能会抛出InterruptException，因为异常不能跨线程传播回main()方法中，因此必须在本地进行处理。线程中抛出的其它异常也必须在本地进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>对静态方法Thread.yield()的调用表明当前线程已经完成了生命周期中最重要的一部分，可以切换给其它线程执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">    Thread.<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、中断"><a href="#五、中断" class="headerlink" title="五、中断"></a>五、中断</h2><p>一个线程执行完毕之后会自动结束，或者在运行过程中发生异常也会提前结束。</p><h3 id="InterruptException"><a href="#InterruptException" class="headerlink" title="InterruptException"></a>InterruptException</h3><p>通过调用一个线程的interrupt()方法来中断线程，如果该线程处于阻塞、限期等待以及无限期等待状态，那么就会抛出InterruptExeption，从而提前结束该线程。但是不能中断IO阻塞以及synchronized锁阻塞。</p><p>对于一下代码，在main()中启动一个线程之后再去中断它，由于线程中调用了Thread.sleep()，因此会抛出一个InterruptException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.InterruptedException</span>: sleep interrupted</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.sleep</span>(Native Method)</span><br><span class="line">    at InterruptExample.lambda<span class="variable">$main</span>$<span class="number">0</span>(InterruptExample<span class="selector-class">.java</span>:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$<span class="variable">$Lambda</span>$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><p>如果一个线程的run方法执行一个无限循环，并且没有sleep()等会抛出InterruptException的操作，那么调用该线程的interrupt()方法就无法提前结束线程。</p><p>但是调用interrupt()会设置线程的中断标记，此时调用interrupted()方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Executor-1"><a href="#Executor-1" class="headerlink" title="Executor"></a>Executor</h3><p>调用Executor的shutdown()方法会等待线程执行完毕之后再关闭，但是如果提前调用shutdownNow()方法，则相当于调用每个线程的interrupt()方法。</p><p>一下使用Lambda创建线程，相当于创建了一个匿名的内部线程。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String []arg)&#123;</span><br><span class="line">    ExecutorService executorService = Executor.newCacheThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(()-&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            Thread.sleep(<span class="number">2000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            System.out.println(<span class="string">"Thread run"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">shutdownNow</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"Main run"</span>)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.InterruptedException</span>: sleep interrupted</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.sleep</span>(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda<span class="variable">$main</span>$<span class="number">0</span>(ExecutorInterruptExample<span class="selector-class">.java</span>:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$<span class="variable">$Lambda</span>$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1142</span>)</span><br><span class="line">    at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">617</span>)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>如果只想中断Executor中的一个线程，可以通过使用submit()方法来提交一个线程，它会返回Futrue&lt;?&gt;对象，通过调用该对象的cancel(true)方法就可以中断该线程。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(<span class="function"><span class="params">()</span> -&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> ..</span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="六、互斥同步"><a href="#六、互斥同步" class="headerlink" title="六、互斥同步"></a>六、互斥同步</h2><p>java提供了两种机制来控制多个线程对共享资源的互斥访问，第一个是基于JVM的synchronized，而另一个是jdk实现的Reentrantlock。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="1、同步一个代码块"><a href="#1、同步一个代码块" class="headerlink" title="1、同步一个代码块"></a>1、同步一个代码块</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只是作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用ExecutorService执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步代码块时，另一个线程就会等待。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SyhchronizedExample</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                System.<span class="keyword">out</span>.print(i+<span class="string">" "</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; e1.func1())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; e1.func1())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象得同步代码块，因此这两个线程就不需要同步。从输出结果就可以看出，两个线程交叉执行。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; e1.func1())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; e2.func1())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="2、同步一个方法"><a href="#2、同步一个方法" class="headerlink" title="2、同步一个方法"></a>2、同步一个方法</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他和同步代码块一样， 作用于一个对象。</p><h4 id="3、同步一个类"><a href="#3、同步一个类" class="headerlink" title="3、同步一个类"></a>3、同步一个类</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    synchronized(<span class="type">SynchronizedExample</span>.<span class="keyword">class</span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类，也就是说两个线程调用同一个类得不同对象上得这种语句，也会进行同步。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; e1.func2())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; e2.func2())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="4、同步一个静态方法"><a href="#4、同步一个静态方法" class="headerlink" title="4、同步一个静态方法"></a>4、同步一个静态方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized static void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是java.util.concurrent(J.U.C)包中的锁。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; lockExample.func())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; lockExample.func())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="1、锁的实现"><a href="#1、锁的实现" class="headerlink" title="1、锁的实现"></a>1、锁的实现</h4><p>synchronized是JVM实现的，而ReentrantLock是jdk实现的。</p><h4 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h4><p>新版本java对synchronized进行了很多优化，例如自旋锁等，synchronized于ReentrantLock大致相同。</p><h4 id="3、等待可中断"><a href="#3、等待可中断" class="headerlink" title="3、等待可中断"></a>3、等待可中断</h4><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其它事情。ReentrantLock可中断，而synchronized不行。</p><h4 id="4、公平锁"><a href="#4、公平锁" class="headerlink" title="4、公平锁"></a>4、公平锁</h4><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized锁是不公平的，ReentrantLock默认也是不公平的，但是可以设置成公平的。</p><h4 id="5、锁绑定多个条件"><a href="#5、锁绑定多个条件" class="headerlink" title="5、锁绑定多个条件"></a>5、锁绑定多个条件</h4><p>一个ReentrantLock锁可以绑定多个Condition对象。</p><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>除非使用ReentrantLock的高级功能，否则优先使用synchronized。这是因为synchronized是JVM实现的锁机制，JVM原生支持它，而RentrantLock不是所有的JDK都支持。并且synchronized不用担心没有释放锁而导致死锁问题，因为JVM会确保锁的释放。</p><h2 id="七、线程之间的协作"><a href="#七、线程之间的协作" class="headerlink" title="七、线程之间的协作"></a>七、线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题的时候，如果某些部分必须在其它部分之前完成，那么就需要对线程进行进行协调。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在线程中调用另一个线程的join()方法，会将当前线程挂起，而不是忙等待，知道目标线程结束。</p><p>对于以下代码，虽然b线程先启动，但是因为在b线程中调用了a线程的join方法，b线程会等待a线程结束才继续执行，因此最后能保证a线程的输出能优先于b线程的输出。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">A</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span>(<span class="type">A</span> a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        <span class="type">A</span> a = <span class="keyword">new</span> <span class="type">A</span>();</span><br><span class="line">        <span class="type">B</span> b = <span class="keyword">new</span> <span class="type">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span></span><br><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>调用wait()使得线程等待某个条件满足，线程在等待时会被挂起，当其它线程的运行使得这个条件满足时，其它线程会调用notify()<br>或者notifyAll()方法来唤醒挂起的线程。</p><p>他们都属于Object的一部分，而不属于Thread。</p><p>只能用在同步方法或者同步代码块中使用，否则会在运行时抛出IllegalMonitorStateExeception。</p><p>使用wait()挂起线程期间，线程会释放锁。这是因为如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行notify或者notifyAll来唤醒挂起的线程，造成死锁。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">after</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; example.after())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; example.before())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">before</span></span><br><span class="line"><span class="keyword">after</span></span><br></pre></td></tr></table></figure><h4 id="wiat-与sleep-的区别"><a href="#wiat-与sleep-的区别" class="headerlink" title="wiat()与sleep()的区别"></a>wiat()与sleep()的区别</h4><ul><li>wait()是Object的方法，而sleep()是Thread的静态方法。</li><li>wait()会释放锁而sleep()不会。</li></ul><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent类中提供了Condition类来实现线程之间的协调，可以在Condition上调用await()方法使线程等待，其它线程调用signal()或者signalAll()唤醒等待的线程。相对于wait()这种等待方法，await()可以指定等待的条件，因此更加灵活。</p><p>使用Lock获取一个Condition对象。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AwaitSignalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.<span class="keyword">await</span>();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; example.after())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; example.before())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">before</span></span><br><span class="line"><span class="keyword">after</span></span><br></pre></td></tr></table></figure><h2 id="八、J-U-C-AQS"><a href="#八、J-U-C-AQS" class="headerlink" title="八、J.U.C - AQS"></a>八、J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提升了并发性能，AQS被认为是J.U.C的核心。</p><h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>用来控制一个线程等待多个线程。</p><p>维护了一个计数器cnt，每次调用countDown()方法都会减1，减到0的时候，那些因为调用await()方法的线程就会被唤醒。</p><p><img src="/img/pl/concurrence_countdownLatch.png" alt=""></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span>&#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] arr) throws InterruptException&#123;</span><br><span class="line">        final int totalThread = <span class="number">10</span>;</span><br><span class="line">        CountdownLatch countDownLatch = <span class="keyword">new</span> CountdownLatch(totalThread);</span><br><span class="line">        ExcutorService excutorService = Excutors.newCacheThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.<span class="built_in">print</span>(<span class="string">"run.."</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                countDownLatch.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">countDownLatch</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"end"</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="built_in">run</span>..<span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>用来控制多个线程相互等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和CountdownLatch相似，都是通过维护计数器来实现的。线程执行await()方法计数器会减1，并进行等待，直到计数器为0，所有调用await()方法而在等待的线程才能继续执行。</p><p>CyclicBarrier与CountdownLatch的一个区别是，CyclicBarrier的计数器通过reset()方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier有两个构造函数，其中parties指示计数器的初始值，barrierAction在所有线程都到达屏障的时候会执行一次。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/pl/concurrence_cyclicBarrier.png" alt=""></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        final int totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.<span class="built_in">print</span>(<span class="string">"before.."</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    cyclicBarrier.await();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">                System.out.<span class="built_in">print</span>(<span class="string">"after.."</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.before</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>.<span class="selector-class">.after</span>..</span><br></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore就是操作系统中的信号量，可以控制互斥资源的访问线程数。</p><p><img src="/img/pl/concurrence_semaphore.png" alt=""></p><p>以下代码模拟了对某个服务的并发请求，每次只能有3个客户端同时访问，请求总数为10。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span>&#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] arr)&#123;</span><br><span class="line">        final int clientCount = <span class="number">3</span>;</span><br><span class="line">        final int totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clinetCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCacheThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; totalRequestCount; i++)&#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.<span class="built_in">print</span>(semaphore.availablePermits() + <span class="string">" "</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">finally</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.release();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="九、J-U-C-其它组件"><a href="#九、J-U-C-其它组件" class="headerlink" title="九、J.U.C - 其它组件"></a>九、J.U.C - 其它组件</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>在介绍Callable的时候我们知道他有返回值，返回值通过Future封装。FutureTask实现了RunnableFuture接口，该接口继承自Runnable以及Future，这使得FutureTask既可以当作一个任务执行也可以有返回值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;V&gt; <span class="title">implements</span> <span class="title">RunnableFuture</span>&lt;V&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>RunnableFuture&lt;V&gt; extends Runnbale, Future&lt;V&gt;</span><br></pre></td></tr></table></figure><p>FutureTask可用于异步获取会执行结果或者取消任务的场景。当一个计算任务需要执行很长时间，那么就可以用FutureTask来封装这个任务，主线程在完成自己的任务后再去获取结果。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                int result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            System.out.println(<span class="string">"other task is running..."</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                Thread.sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">otherThread</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(futureTask.get())</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other <span class="keyword">task</span> <span class="keyword">is</span> running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li>FIFO队列：LinkedBlockingQueue ArrayBlockingQueue</li><li>优先级队列：PriorityBlockQueue</li></ul><p>提高了阻塞的take()与put()方法：如果队列为空，take()方法将阻塞，直到队列中有内容；如果队列已满，put()将阻塞，直到队列有空闲位置。</p><h4 id="使用BlockingQueue实现生产者消费者问题"><a href="#使用BlockingQueue实现生产者消费者问题" class="headerlink" title="使用BlockingQueue实现生产者消费者问题"></a>使用BlockingQueue实现生产者消费者问题</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="type">BlockingQueue</span>&lt;<span class="type">String</span>&gt; queue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">System</span>.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">System</span>.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">produce.<span class="selector-class">.produce</span>.<span class="selector-class">.consume</span>.<span class="selector-class">.consume</span>.<span class="selector-class">.produce</span>.<span class="selector-class">.consume</span>.<span class="selector-class">.produce</span>.<span class="selector-class">.consume</span>.<span class="selector-class">.produce</span>.<span class="selector-class">.consume</span>..</span><br></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>主要用于并行计算，和MapReduce原理类似，都是把大的任务拆分成小的任务并行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoin使用ForkJoinPool来启动，它是一个特殊的线程池，线程数量取决于CPU核数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p>ForkJoinPool使用了工作窃取算法来提高CPU的利用率。每个线程都维护了一个双端队列，用来存储需要执行任务。工作窃取算法是允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2从Thread1的队列中拿出最晚的Task1任务，Thread1会拿出Task2来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><img src="/img/pl/concurrence_forkjoin.png" alt=""></p><h2 id="十、线程不安全示例"><a href="#十、线程不安全示例" class="headerlink" title="十、线程不安全示例"></a>十、线程不安全示例</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了1000个线程同时对cnt执行自增操作，操作结束之后它的值可能小于1000。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    final int threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    final CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            example.add();</span></span></span><br><span class="line"><span class="function"><span class="params">            countDownLatch.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">countDownLatch</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(example.get())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">997</span></span><br></pre></td></tr></table></figure><h2 id="十一、java内存模型"><a href="#十一、java内存模型" class="headerlink" title="十一、java内存模型"></a>十一、java内存模型</h2><p>Java内存模型试图屏蔽各种硬件与操作系统的内存访问差异，以实现让java程序在各种平台都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>处理器上的寄存器处理速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存可能带来的一个问题是：缓存一致性，如果多个缓存共享同一个主内存区域，那么多个缓存的数据可能会不同，需要一些协议来解决这些问题。</p><p><img src="/img/pl/concurrence_memory.png" alt=""></p><p>所有的变量都存储在主内存上，每个线程都还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存完成。</p><p><img src="/img/pl/concurrence_memory_model.png" alt=""></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java内存模型定义了8个操作来完成主内存与工作内存的交互操作。</p><p><img src="/img/pl/concurrence_memory_model1.png" alt=""></p><ul><li>read:把一个变量的值从主内存传到工作内存中</li><li>load:在read之后执行，把read得到的值放入工作内存的副本中</li><li>use：把工作内存中的一个变量值传递给执行引擎</li><li>assign:把一个从执行引擎接收到的值赋给工作内存中的变量</li><li>store:把工作内存中的变量的值传给主内存</li><li>write:在store之后执行，把store得到的值放入主内存的变量中</li><li>lock:作用于主内存中的变量</li><li>unlock:</li></ul><h3 id="内存三大模型特性"><a href="#内存三大模型特性" class="headerlink" title="内存三大模型特性"></a>内存三大模型特性</h3><h4 id="1、原子性"><a href="#1、原子性" class="headerlink" title="1、原子性"></a>1、原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的变量在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 变量属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 变量进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入该变量的值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><img src="/img/pl/concurrence_memory_atom.png" alt=""></p><p>AtomicInteger能够保证多个线程修改的原子性。</p><p><img src="/img/pl/concurrence_memory_atom2.png" alt=""></p><p>使用AtomicInteger重写之前线程不安全的代码之后得到以下线程安全实现：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="keyword">new</span> AtomicExample(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.<span class="built_in">add</span>();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.<span class="built_in">println</span>(example.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure><p>除了使用原子类以外，还可以使用互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock和unlock，在虚拟机上对应的字节码指令为monitorenter和monitorexit。</p><h4 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h4><p>可见性是指当一个修改了共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存中，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对于一个变量执行unlock操作之前，必须把变量值同步回主内存。</li><li>final，被final修饰的字段一旦在构造器中初始化完成，并且没有发生this逃逸（其它线程通过this访问了初始化一半的对象），那么其它线程就能看到final的值。</li></ul><p>对前面的线程不安全示例中的cnt变量使用volatile修饰，不能解决线程不安全的问题，因为volatile不能保证操作的原子性。</p><h4 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有的操作都是无序的，无序是因为发生了指令重排序。</p><p>在java内存模型中，允许编译器与处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile通过添加内存屏障的方式来禁止指令重排序，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过synchronized来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于让线程顺序执行同步代码。</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>上面提到可以通过volatile以及synchronized来保证有序性。除此之外，JVM还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h4 id="1、单一线程原则"><a href="#1、单一线程原则" class="headerlink" title="1、单一线程原则"></a>1、单一线程原则</h4><p>在一个线程内程序前面操作先于后面的操作。</p><h4 id="2、管程锁定原则"><a href="#2、管程锁定原则" class="headerlink" title="2、管程锁定原则"></a>2、管程锁定原则</h4><p>一个unlock操作先于发生后面对同一个锁的lock操作。</p><h4 id="3、volatile变量规则"><a href="#3、volatile变量规则" class="headerlink" title="3、volatile变量规则"></a>3、volatile变量规则</h4><p>对于一个volatile变量的写操作先于后面对这个变量的读操作</p><h4 id="4、线程启动规则"><a href="#4、线程启动规则" class="headerlink" title="4、线程启动规则"></a>4、线程启动规则</h4><p>Thread对象的start()方法调用先行发生于此线程的每一个动作。</p><h4 id="5、线程加入规则"><a href="#5、线程加入规则" class="headerlink" title="5、线程加入规则"></a>5、线程加入规则</h4><p>Thread对象的结束先行发生于join方法的返回</p><h4 id="6、线程中断规则"><a href="#6、线程中断规则" class="headerlink" title="6、线程中断规则"></a>6、线程中断规则</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()检测到是否有中断发生。</p><h4 id="7、对象终结规则"><a href="#7、对象终结规则" class="headerlink" title="7、对象终结规则"></a>7、对象终结规则</h4><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p><h4 id="8、传递性规则"><a href="#8、传递性规则" class="headerlink" title="8、传递性规则"></a>8、传递性规则</h4><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p><h2 id="十二、线程安全"><a href="#十二、线程安全" class="headerlink" title="十二、线程安全"></a>十二、线程安全</h2><h3 id="线程安全的定义"><a href="#线程安全的定义" class="headerlink" title="线程安全的定义"></a>线程安全的定义</h3><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><h3 id="线程安全分类"><a href="#线程安全分类" class="headerlink" title="线程安全分类"></a>线程安全分类</h3><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h4 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h4><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p><p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 * AtomicInteger 和 AtomicLong 则是可变的。</li></ul><h4 id="2、绝对线程安全"><a href="#2、绝对线程安全" class="headerlink" title="2、绝对线程安全"></a>2、绝对线程安全</h4><p>不管运行环境如何，调用者都不需要任何额外的同步操作</p><h4 id="3、相对线程安全"><a href="#3、相对线程安全" class="headerlink" title="3、相对线程安全"></a>3、相对线程安全</h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><p>对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorUnsafeExample</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; <span class="built_in">vector</span> = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-159738"</span> java<span class="selector-class">.lang</span><span class="selector-class">.ArrayIndexOutOfBoundsException</span>: Array index out of range: <span class="number">3</span></span><br><span class="line">    at java<span class="selector-class">.util</span><span class="selector-class">.Vector</span><span class="selector-class">.remove</span>(Vector<span class="selector-class">.java</span>:<span class="number">831</span>)</span><br><span class="line">    at VectorUnsafeExample.lambda<span class="variable">$main</span>$<span class="number">0</span>(VectorUnsafeExample<span class="selector-class">.java</span>:<span class="number">14</span>)</span><br><span class="line">    at VectorUnsafeExample$<span class="variable">$Lambda</span>$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>如果要保证上面的代码能够正确的执行下去，就需要对删除元素与获取元素进行同步。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    synchronized (vector) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            vector.remove(i);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    synchronized (vector) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            vector.get(i);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br></pre></td></tr></table></figure><h4 id="4、线程兼容"><a href="#4、线程兼容" class="headerlink" title="4、线程兼容"></a>4、线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p><h4 id="5、线程对立"><a href="#5、线程对立" class="headerlink" title="5、线程对立"></a>5、线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中使用并发代码。由于java语言天生就具备多线程的特性，线程对立这种排斥多线程的代码很少出现的，通常都是有害的，应当尽量避免。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="1、互斥同步"><a href="#1、互斥同步" class="headerlink" title="1、互斥同步"></a>1、互斥同步</h4><p>synchronized与ReentrantLock</p><h4 id="2、非阻塞同步"><a href="#2、非阻塞同步" class="headerlink" title="2、非阻塞同步"></a>2、非阻塞同步</h4><p>互斥同步最主要的问题就是线程阻塞以及唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h5 id="（一）-CSA"><a href="#（一）-CSA" class="headerlink" title="（一） CSA"></a>（一） CSA</h5><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h5 id="（二）AtomicInteger"><a href="#（二）AtomicInteger" class="headerlink" title="（二）AtomicInteger"></a>（二）AtomicInteger</h5><p>J.U.C包里面的整数原子类AtomicInteger,其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（三）ABA"><a href="#（三）ABA" class="headerlink" title="（三）ABA"></a>（三）ABA</h5><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h4 id="3、无同步方案"><a href="#3、无同步方案" class="headerlink" title="3、无同步方案"></a>3、无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h5 id="一-栈封闭"><a href="#一-栈封闭" class="headerlink" title="(一)栈封闭"></a>(一)栈封闭</h5><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute<span class="function"><span class="params">(() -&gt; example.add100())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">execute</span><span class="params">(() -&gt; example.add100())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h5 id="（二）线程本地存储（Thread-Local-Storage）"><a href="#（二）线程本地存储（Thread-Local-Storage）" class="headerlink" title="（二）线程本地存储（Thread Local Storage）"></a>（二）线程本地存储（Thread Local Storage）</h5><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal.set(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                Thread.sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            System.out.println(threadLocal.get());</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal.remove();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span> <span class="title">thread2</span> = <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal.set(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal.remove();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread1</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread2</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了理解 ThreadLocal，先看以下代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal1.set(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal2.set(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">Thread</span> <span class="title">thread2</span> = <span class="title">new</span> <span class="title">Thread</span><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal1.set(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            threadLocal2.set(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread1</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread2</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>它所对应的底层结构图为：</p><p><img src="/img/pl/concurence_threadLocal.png" alt=""></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining <span class="keyword">to</span> this thread. This map <span class="keyword">is</span> maintained</span><br><span class="line"> * <span class="keyword">by</span> <span class="keyword">the</span> ThreadLocal <span class="built_in">class</span>. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</span><br><span class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get() 方法类似。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h5 id="（三）可重入代码（Reentrant-Code）"><a href="#（三）可重入代码（Reentrant-Code）" class="headerlink" title="（三）可重入代码（Reentrant Code）"></a>（三）可重入代码（Reentrant Code）</h5><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h2 id="十三、-锁优化"><a href="#十三、-锁优化" class="headerlink" title="十三、 锁优化"></a>十三、 锁优化</h2><p>这里的优化主要是指JVM对synchronized的优化</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> static <span class="keyword">String </span>concatString(<span class="keyword">String </span><span class="built_in">s1</span>, <span class="keyword">String </span><span class="built_in">s2</span>, <span class="keyword">String </span><span class="built_in">s3</span>) &#123;</span><br><span class="line">    return <span class="built_in">s1</span> + <span class="built_in">s2</span> + <span class="built_in">s3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> static <span class="keyword">String </span>concatString(<span class="keyword">String </span><span class="built_in">s1</span>, <span class="keyword">String </span><span class="built_in">s2</span>, <span class="keyword">String </span><span class="built_in">s3</span>) &#123;</span><br><span class="line">    <span class="keyword">StringBuffer </span><span class="built_in">sb</span> = new <span class="keyword">StringBuffer();</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">sb</span>.append(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">sb</span>.append(<span class="built_in">s2</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">sb</span>.append(<span class="built_in">s3</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="built_in">sb</span>.toString()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><h2 id="十四、多线程开发良好的实践"><a href="#十四、多线程开发良好的实践" class="headerlink" title="十四、多线程开发良好的实践"></a>十四、多线程开发良好的实践</h2><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建 Thread 对象，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.<br>Threads and Locks</li><li>线程通信</li><li>Java 线程面试题 Top 50</li><li>BlockingQueue</li><li>thread state java</li><li>CSC 456 Spring 2012/ch7 MN</li><li>Java - Understanding Happens-before relationship</li><li>6장 Thread Synchronization</li><li>How is Java’s ThreadLocal implemented under the hood?</li><li>Concurrent</li><li>JAVA FORK JOIN EXAMPLE</li><li>聊聊并发（八）——Fork/Join 框架介绍</li><li>Eliminating SynchronizationRelated Atomic Operations with * Biased Locking and Bulk Rebiasing</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍java中并发相关的线程（Thread）、线程池、线程同步以及协作、java内存模型以及锁相关的内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="并发" scheme="//plstyle.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并行" scheme="//plstyle.cn/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="线程安全" scheme="//plstyle.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——工厂模式</title>
    <link href="//plstyle.cn/2018/08/27/blog_pattern_factory/"/>
    <id>//plstyle.cn/2018/08/27/blog_pattern_factory/</id>
    <published>2018-08-27T04:00:00.000Z</published>
    <updated>2018-09-04T01:53:43.148Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍工厂模式中的简单工厂、工厂方法以及抽象工厂模式。<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>工厂模式顾名思义就是提供一个工厂用于生产创建对象之用，工厂模式相关的有简单工厂、工厂方法以及抽象工厂，以下会一一介绍。</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>在创建一个对象时不向客户端暴露内部细节，并提供一个创建对象的通用接口。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类与具体子类的实现解耦，客户类不需要知道有哪些子类以及应当实例化哪些子类。因为客户类往往有很多个，如果不使用简单工厂，所有的客户类都需要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都需要进行修改。以下为类图：</p><p><img src="/img/pl/pattern_simple_class.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Product&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>以下的SimpleFactory是简单工厂的实现，它被所有需要进行实例化的客户端类调用。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SimpleFactory&#123;</span><br><span class="line">    <span class="keyword">public</span> Product createProduct(int <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span> </span>== <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        SimpleFactory factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = factory.createProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p>在简单工厂中，创建对象的是一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory有一个doSomething()方法，这个方法需要用一个产品对象，这个产品对象由factoryMethod()方法创建。该方法是抽象的，需要由子类去实现。以下为类图：</p><p><img src="/img/pl/pattern_factory_method_class.png" alt=""></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Factory</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Product product = factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public <span class="type">Product</span> factoryMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public <span class="type">Product</span> factoryMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public <span class="type">Product</span> factoryMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] arg)&#123;</span><br><span class="line">    Factory  <span class="keyword">factory</span> = <span class="keyword">new</span> ConcreteFarctory();</span><br><span class="line">    <span class="keyword">factory</span>.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Product相关的类之前已经给出，这里就不重复给与了。相对于简单工厂，工厂方法就是把简单工厂类创建对象的逻辑换成抽象类继承的方式来实现，具体调用会有些许差异，不过耦合性更低，在添加产品时，只需要创建一个产品工厂，不需要去修改之前的代码逻辑。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>提供一个接口，用于创建相关的对象家族。</p><h3 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h3><p>抽象工厂创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只适用于创建一个对象，这和抽象工厂模式由很大的不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA和createProductB都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法的定义。</p><p>至于创建对象家族这一概念是在Client中体现，Client需要通过AbstractFactory同时调用两个方法来创建两个对象，在这里这两个对象由很多的相关性，Client需要同时创建出这两个对象。</p><p>从高层次看，抽象工厂使用了组合，即Client组合了AbstractFactory，而工厂方法使用了继承。类图如下：</p><p><img src="/img/pl/pattern_abstract_factory_class.png" alt=""></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="type">AbstractProductA</span> createProductA() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AbstractProductB</span> createProductB() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="type">AbstractProductA</span> createProductA() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AbstractProductB</span> createProductB() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory abstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA = abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB = abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍工厂模式中的简单工厂、工厂方法以及抽象工厂模式。&lt;br&gt;
    
    </summary>
    
    
      <category term="工厂模式" scheme="//plstyle.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系简述</title>
    <link href="//plstyle.cn/2018/08/18/blog_view_distribute/"/>
    <id>//plstyle.cn/2018/08/18/blog_view_distribute/</id>
    <published>2018-08-18T04:00:00.000Z</published>
    <updated>2018-08-23T08:35:51.107Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍Android平台View的基础知识、事件分发机制以及常见的滑动冲突与对应的处理<br><a id="more"></a></p><h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><h3 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View"></a>什么是View</h3><p>View是Android中所有控件的基类，不管是简单的Button以及TextView还是复杂的RelativeLayout与ListView，它们的共同基类都是View。所以说View是一种界面层的控件的一种抽象，它代表了一个控件。除了View，还有ViewGroup，顾名思义，它内部包含了很多控件，ViewGroup也是继承自View，这意味着View本身就可以是单个控件也可以是多个控件组成的一组控件，通过这种关系就形成了View树的结构，这个和Web中的DOM树的概念很相似。View就相当于Dom中的节点，它可以是单个的View，也可以是包含View的ViewGroup。所以说Android界面构成实质上就是View树的绘制。</p><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top、left、right、buttom，其中（left,top）代表左上角的坐标，(right,bottom)代表右下角的坐标,需要注意的是，这些坐标都是相对于父容器来说的，它是一种相对坐标，View的坐标和父容器的关系如下图：</p><p><img src="/img/pl/view_relation.png" alt=""></p><p>在Android中，x轴和Y轴的正方向分别为向右与向下，这点不难理解，不仅仅是Android，大部分显示系统都是按照这个标准来定义坐标的。由图可知：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span> = right - left<span class="comment">;</span></span><br><span class="line"><span class="attribute">height</span> = bottom - top<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>View的四个参数对应的获取方法分别为：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">left</span> = getLeft()<span class="comment">;</span></span><br><span class="line"><span class="attribute">right</span> = getRight()<span class="comment">;</span></span><br><span class="line"><span class="attribute">top</span> = getTop()<span class="comment">;</span></span><br><span class="line"><span class="attribute">bottom</span> = getBottom()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>在Android3.0新增了几个参数，x、y、translationX以及translationY,其中x与y是View左上角的坐标，而translationX与translationY是View左上角相对于父容器的偏移量，这几个参数也是相对于父容器，而translationX与translationY的默认值为0，和View的四个基本参数一样，View也为其提供了get/set方法，这个参数的换算关系如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span> = left + translationX;</span><br><span class="line"><span class="attribute">y</span> = top + translationY;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在平移的过程中，top与left分别代表的是原始左上角的位置信息，其值并不会改变，此时变化的是x、y、translationX以及translationY这四个参数。</p><h3 id="MotionEvent与TouchSlop"><a href="#MotionEvent与TouchSlop" class="headerlink" title="MotionEvent与TouchSlop"></a>MotionEvent与TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>在手指触摸屏幕后所产生的一系列事件中，典型的事件类型有以下几种：</p><ul><li>ACTION_DOWN——手指刚接触屏幕</li><li>ACTION_MOVE——手指在屏幕滑动</li><li>ACTION_UP——手指从屏幕上松开的瞬间</li></ul><p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：</p><ul><li>点击屏幕后松开，事件顺序为DOWM——UP;</li><li>点击屏幕后滑动一会松开，事件顺序为DOWN——MOVE——MOVE…——UP；</li></ul><p>上述三种情况是典型的事件序列，通过可以通过MotionEvent得到点击事件发生的x以及Y坐标。为此，系统提供了两组方法：getX/getY以及getRawX/getRawY。它们的区别很简单，前者返回的是相对于当前View左上角的x和y的坐标，而后者返回的是相对于手机屏幕左上角的x和y的坐标</p><h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop是系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕上滑动时，如果两次的滑动之间的距离小于这个常量,那么系统就不认为你是在进行滑动操作。原因很简单，滑动距离太小，系统不认为这是一个滑动操作。这是一个常量，和设备有关，在不同的设备上这个值可能是不同的，通过如下方式可以获取这个常量:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ViewConfigution</span><span class="selector-class">.get</span>(<span class="selector-tag">getContext</span>())<span class="selector-class">.getScaleTouchSlop</span>()</span><br></pre></td></tr></table></figure></p><p>这个常量有什么意义呢？当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样做可以有更好的用户体验。</p><h3 id="VelocityTracker、GestureDetector和Scroller"><a href="#VelocityTracker、GestureDetector和Scroller" class="headerlink" title="VelocityTracker、GestureDetector和Scroller"></a>VelocityTracker、GestureDetector和Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平与垂直方向的速度。它的使用过程很简单，首先，在View的onTouchEvent方法中追踪当前点击事件的速度：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示单位时间内像素数</span></span><br><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(<span class="keyword">event</span>);</span><br><span class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>)velocityTracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>)velocityTracker.getYVelocity();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用的话就将其释放</span></span><br><span class="line">velocityTracker.<span class="keyword">clear</span>();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure></p><h4 id="gestureDetector"><a href="#gestureDetector" class="headerlink" title="gestureDetector"></a>gestureDetector</h4><p>手势检测，用于辅助检测用户的单机、滑动、长按、双击等行为。使用GestureDetector很简单，只需要创建一个GestureDetector对象并且实现OnGestureListener接口，接着接管onTouchEvent方法，具体实现如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GesTureDector(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//解决长按屏幕无法拖动的现象</span></span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//在待监听的View的onTouchEvent方法中实现如下：</span></span><br><span class="line"><span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure></p><p>当然，OnGestureListener还有很多回调方法，这里就不一一介绍了。</p><h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>弹性滑动对象，用于实现View的弹性滑动。我们知道，当使用View的scrollBy或者scrollTo方法来进行滑动时，其过程时瞬间完成的，这个没有过渡效果的滑动用户体验不好。它的典型代码时固定的，具体实现如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scroller scroller = <span class="keyword">new</span> Scroller(mContext);</span><br><span class="line"><span class="comment">//缓慢滑动到指定位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">smoothScroller</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> delta = destX - scrollX;</span><br><span class="line">    <span class="comment">//1000ms内滑动到destX,效果就是慢慢滑动</span></span><br><span class="line">    mScroller.startScroll(scrollX,<span class="number">0</span>,delta,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//startScroll只是做了更新数据，真正进行滑动是由invalidate()方法执行的</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>补充说明以下，弹性滑动除了可以使用Scroller实现，还可以使用动画以及延时策略。使用动画只要为其设置一个执行动画的时间值即可，而延迟策略就是采用postDelay或者sleep等方法延迟执行滑动动作，从而可以实现弹性滑动的效果。</p><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View的滑动，在Android设备上，滑动几乎是应用的标配，不管是下拉刷新还是SlidingMenu，它们的基础都是滑动。从另一方面说，Android手机屏幕比较小，为了给用户呈现更多的内容，就需要滑动来显示与隐藏一些内容。由此可见，滑动在Android开发中是多么的重要。</p><h3 id="scrollTo与scrollBy"><a href="#scrollTo与scrollBy" class="headerlink" title="scrollTo与scrollBy"></a>scrollTo与scrollBy</h3><p>scrollTo与scrollBy是View提供的两个实现滑动的方法，scrollBy的内部实现也是scrollTo，只是入参不同而已，只不过scrollBy是基于当前位置的滑动，而scrollTo是基于所传参数的绝对滑动。</p><h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>动画本身就支持平移等操作，平移就是一种滑动，使用动画来移动View,主要就是操作View的translationX以及translationY属性，既可以使用传统的View动画，也可以使用属性动画（属性动画是在Android3.0引入的，如果对Android版本要求不高，优先使用属性动画。）</p><h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>改变布局参数，即改变LayoutParam。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParam <span class="built_in">param</span> = (MarginLayoutParam)button.getLayoutParam();</span><br><span class="line"><span class="built_in">param</span>.width += <span class="number">10</span>;</span><br><span class="line"><span class="built_in">param</span>.leftMargin += <span class="number">100</span>;</span><br><span class="line">button.setLayoutParam(<span class="built_in">param</span>);</span><br><span class="line"><span class="comment">//或者button.requestLayout()；</span></span><br></pre></td></tr></table></figure></p><h3 id="各种滑动方式对比"><a href="#各种滑动方式对比" class="headerlink" title="各种滑动方式对比"></a>各种滑动方式对比</h3><p>先看scrollTo/scrollBy这种方式，它是View提供的原生的方法，其作用是专门用于View的滑动，它可以比较方便的实现滑动效果并且不影响内部元素的点击事件。但它的最大缺点也是很显然：它只能滑动View的内容，不能滑动View本身以及View在布局中的位置。</p><p>动画来实现滑动的话，要分情况，如果是Android3.0以上的话，用属性动画来实现，没有什么明显的缺点；如果是View的动画或者在Android3.0以下使用属性动画，均不能改变View的属性。在实际使用中，如果动画不影响交互的话，那么使用动画来做滑动是比较合适的，否则不合适。但是动画有个很明显的优点，那就是一些复杂的效果必须要用动画来实现。</p><p>使用改变布局的这种方式，除了使用起来比较麻烦，也没有明显的缺点，它的主要适用对象是一些具有交互性的View，因为这些View需要和用户交互，使用动画就会有问题。</p><p>所以总结以下就是：</p><ul><li>scrollTo/scrollBy:操作简单，适合对View内容的滑动</li><li>动画：操作简单，主要使用于没有交互的View以及复杂的动画效果</li><li>改变布局参数：操作稍微复杂，适用于有交互的View</li></ul><h2 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h2><h3 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h3><p>在介绍点击事件的传递规则前，首先我们要明白这里要分析的对象是MotionEvent，即点击事件。所谓点击事件的分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递过程就是分发过程。点击事件的分发由三个很重要的方法来共同完成:dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。</p><ul><li>dispatchTouchEvent:用来进行事件分发。如果事件能够到达当前View，那么此方法一定会被调用，返回结果受当前View以及下级的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</li><li>onInterceptTouchEvent:在dispatchTouchEvent方法中调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截此事件。</li><li>onTouchEvent:在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在用一个事件序列，当前事件无法再次接收到事件。</li></ul><p>三个方法之间的关系用伪代码表示如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(e))&#123;</span><br><span class="line">        consume = onTouchEvent(e);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure></p><h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p>对于根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInteceptTouchEvent返回true就表示它要拦截当前事件，接着这个事件就会这个ViewGroup来处理，即它的的onTouchEvent方法就会被调用；如果这个onInterceptTouchEvent方法返回false，就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispacthTouchEvent方法就会被调用，如此反复直到事件被最终处理为止。</p><p>当一个View处理事件时，如果它设置了OnTouchListener，那么OnTouchListenr中的onTouch方法就会被调用。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的onTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前方法有设置OnClickListener，那么它的onClick方法将被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p><p>当一个事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity在传给Window，最后Window再传递给View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的OnTouchEvent返回false，那么它的父容器的onTouchEvent将被调用，依次类推。如果所有的元素都不处理这个事件，那么这个事件最终将会交给Activity来处理，即Activity的onTouchEvent方法将会被调用。这个过程其实很好理解，我们换一种思路，加入点击事件是一个难题，这个难题被上级领导分配给了一个程序员去处理（这是事件分发过程），结果这个程序员搞不定（onTouchEvent方法返回了false），现在该怎么办呢？难题必须要解决，那只能交由水平更高的上级去解决（上级的onTouchEvent被调用），如果上级再搞不定，那只能交由上级的上级去解决，就这样将难题一层层的往上抛，这是公司内部一种很常见的处理问题的机制。从这个角度来看，View的事件传递还是还贴近现实的，毕竟程序员也生活在现实生活中。</p><p>关于事件传递的机制，这里给出一些结论，根据这些结论可以更好的理解整个传递机制：</p><ul><li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程所产生的一系列的事件，这个事件序列以down开始，中间含有数量不定的move事件，最终以up事件结束。</li><li>正常情况下，一个事件序列只能被一个View拦截且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了此事件，那么同一个事件序列的所有事件都会直接交由它处理，因此同一个事件序列中的事件不能同时由两个View处理，但是通过特殊的手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其它的View处理。</li><li>某个View一旦决定开始拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInteceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的方法都直接交由它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。</li><li>某个View事件一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其它事件都不会交给他处理，并且事件将重新交给他的父元素去处理，即父元素的onTouchEvent会被调用。意思就是一个事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不在交给它处理了，这就好比上级交给程序员一件事，如果这件事没有处理好，短期内这个上级就不敢把事件交给这个程序员做了，二者是类似的道理。</li><li>如果View不消耗除了ACTION_DOWN以外的其它点击事件，那么这个点击事件就会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</li><li>ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false。</li><li>View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li><li>View的onTouchEvent默认都会消耗事件（即返回true）,除非它是不可点击的（clickable和longClickable为false)。View的longClickable默认为false，clickable要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</li><li>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable为true，那么它的onTouchEvent就返回true。</li><li>onClick能发生的前提是View是可点击的，并且它受到了down与up的事件。</li><li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再有父元素分发给子View，通过requestDisallowInteceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li></ul><h2 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h2><p>相信开发Android的都会有这种体会：滑动冲突太坑人了，本来网上下载好的demo好好的，但是只要出现滑动冲突，demo就无法正常工作了。那么滑动冲突时如何产生的呢？其实在界面中，只要内外两层可以同时滑动，这个时候就会产生滑动冲突。如何解决滑动冲突呢？这既是一件困难的事又是一件简单的事，说困难是因为很多开发者面对滑动冲突都会显得束手无策，说简单是因为滑动冲突的解决有固定的套路，只要知道了这个套路问题就好解决了。</p><h3 id="常见的滑动冲突场景"><a href="#常见的滑动冲突场景" class="headerlink" title="常见的滑动冲突场景"></a>常见的滑动冲突场景</h3><p>常见的滑动冲突可以分为以下三种：</p><ul><li>场景1——外部滑动方向与内部滑动方向不一致</li><li>场景2——外部滑动方向与内部滑动方向一致</li><li>上面两种情况的嵌套</li></ul><p>先说场景1，主要是将ViewPager与Fragment配合使用所组成的页面滑动效果，主流应用几乎都会使用这个效果。在这种效果中，可以通过左右滑动来切换页面，而每个页面内部又嵌套了一个ListView。本来这种情况是有滑动冲突的，但是ViewPager内部处理了这个滑动冲突，因此采用ViewPager时我们无须关注此问题。如果我们采用的不是ViewPager而是ScrollView等，那就必须手动处理滑动冲突了，否则造成的后果就是内外两层只有一层能进行滑动，这是因为两者之间的滑动事件有冲突。除了这种典型情况外，还存在其它的情况，比如外部上下滑动，内部左右滑动等，但是它们属于同一类滑动冲突。</p><p>再说场景2，这种情况稍微复杂些，当内外两层都在同一个方向可以进行滑动时，显然存在逻辑问题。因为当手指开始滑动时，系统无法知道用户到底是想让哪一层滑动，所以当手指滑动的时候就会出现问题，要么只有一层滑动，要么就是两层都滑动但是很卡顿。在实际开发中，这种场景主要是指内外两层同时上下滑动或者内外层同时左右滑动。</p><p>最后说下场景3，其实就是上面两种情况的嵌套，因此场景3的滑动冲突看起来就更复杂了。虽然说场景3滑动冲突看起来很复杂，但是它是几个单一滑动冲突的叠加，因此只需要处理内层和中层、中层与外层之间的滑动冲突即可，而具体的处理方法其实是和场景1、场景2相同的。</p><p>从本质上讲，这三种滑动冲突场景的复杂度其实是相同的，因为它们的区别仅仅是滑动策略的不同，至于解决滑动冲突的方法，它们几个是通用的，以下篇幅会做相应的介绍。</p><h3 id="滑动冲突的处理规则"><a href="#滑动冲突的处理规则" class="headerlink" title="滑动冲突的处理规则"></a>滑动冲突的处理规则</h3><p>一般来说，不管滑动冲突多么复杂，它都有既定的规则，根据这些规则我们可以选择合适的方法去处理。</p><p>对于场景1，它的处理规则是：当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部的View拦截点击事件。这个时候我们就可以根据它的特征来解决滑动冲突，具体来说是：根据滑动是水平滑动还是竖直滑动来判断到底是谁来拦截事件。根据滑动过程中两个点之间的坐标就可以得出到底是水平还是竖直滑动。简单来说，可以有很多的参考，依据滑动路径与水平方向上的夹角，也可以一句水平方向与竖直方向的距离差来判定，某些特殊时候还可以依据水平与竖直方向的速度差来判断。选用规则可以结合具体场景来选择。</p><p>对于场景2，比较特殊，无法根据角度、距离差以及速度差来判断，但是这个时候一般都能在业务上找到突破点，比如业务上规定：当处于某种状态时需要外部View响应用户的滑动，而处于另外一种状态时需要内部View来响应View的滑动，根据这种业务需求我们也能指定出相应的处理规则，有了处理规则同样可以进行下一步的处理。</p><p>对于场景3，它的滑动规则更复杂了，和场景2一样，它也无法根据角度、距离差以及速度差来判断，同样还是只能从业务上找突破点，具体方法和场景2一样，都是从业务的需求得出对应的处理规则。</p><h3 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h3><p>首先我们分析滑动场景，这也是最简单、最典型的滑动冲突，因为它的滑动规则比较简单，不过多复杂的滑动冲突，它们之间的区别仅仅是滑动规则不同而已。抛开滑动规则不说，我们需要找到一种不依赖具体滑动的滑动规则的通用的解决方法，在这里我们需要根据场景1得出通用的解决方案，然后场景2、3只需要修改有关滑动规则的逻辑即可。</p><h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><p>所谓外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就进行拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题，这种方法比较符合事件的分发机制。外部拦截法需要重写父容器的onteceptTouchEvent方法，在内部做相应的拦截即可，伪代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">onInterceptTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">    boolean intecepted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">event</span>.getX();</span><br><span class="line">    <span class="keyword">int</span> y = <span class="keyword">event</span>.getY();</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">event</span>.getAction())&#123;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">          inteceped = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_MOVE：</span><br><span class="line">          <span class="keyword">if</span>(<span class="string">"父容器需要拦截此事件"</span>）</span><br><span class="line">            intecepted =<span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            intecepted = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">          intecepted = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> intecepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其它均不需做修改并且也不能修改。这里对上述代码在描述一下，在onInteceptTouchEvent方法中，首先是ACTION_DOWN事件，父容器必须返回false，即不拦截此事件，这是因为一旦父容器拦截了此事件，后续的事件都会直接交由父容器处理，这个时候事件就没办法再传递给子元素了；其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否需要拦截，如果父容器需要拦截就返回true，否则返回false；最后是ACTIO_UP事件，这里必须返回false，因为ACTION_UP事件本身没有太多意义。</p><p>考虑一种情况，假设事件交由子元素处理，如果父容器再ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素的onClick方法就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交由它处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInteceptTouchEvent方法方法在ACTION_UP中返回了false。</p><h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><p>内部拦截法是指父容器不拦截任何事件，所有的事件都交由子元素，如果子元素需要此事件就消耗掉，否则就交由父容器处理，这种  方法和Android中的事件分发不一致，需要配合requestDisallowInteceptTouchEvent方法才能正常工作，使用起来较外部拦截法稍显复杂。伪代码如下,我们需要重写dispatchTouchEvent方法:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">onInterceptTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">event</span>.getX();</span><br><span class="line">    <span class="keyword">int</span> y = <span class="keyword">event</span>.getY();</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">event</span>.getAction())&#123;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">          parent.requestDisallowInteceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_MOVE：</span><br><span class="line">          <span class="keyword">if</span>(<span class="string">"父容器需要此类点击事件"</span>)</span><br><span class="line">            parent.requestDisallowInteceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> super.dispatchTouchEvent(<span class="keyword">event</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面的条件即可，其它不需要改动而且也不能改动。除了子元素需要做特殊处理外，父元素也要默认拦截除了ACTION_DOWN以外的其它事件，这样当子元素调用parent.requestDisallowInteceptTouchEvent(false)时，父元素才能继续拦截所需的事件。</p><p>为什么父容器不能拦截ACTION_DOWN事件呢？那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传到子元素中了，这样内部拦截就不起作用了。父元素所作修改如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">onInterceptTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">int</span> action = <span class="keyword">event</span>.getAction();</span><br><span class="line">     <span class="keyword">if</span>(action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="滑动冲突总结"><a href="#滑动冲突总结" class="headerlink" title="滑动冲突总结"></a>滑动冲突总结</h4><p>所以对于滑动冲突，内部拦截法与外部拦截法都适用，当面对不同的滑动策略时只需要修改里面的条件即可，外部拦截法相对内部拦截法来说更简单更容易理解，可以优先考虑使用。</p><p>参考书籍: 《Android开发艺术探索》   </p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍Android平台View的基础知识、事件分发机制以及常见的滑动冲突与对应的处理&lt;br&gt;
    
    </summary>
    
    
      <category term="View滑动" scheme="//plstyle.cn/tags/View%E6%BB%91%E5%8A%A8/"/>
    
      <category term="事件分发" scheme="//plstyle.cn/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
      <category term="滑动冲突" scheme="//plstyle.cn/tags/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>关于代码可读性的一些见解</title>
    <link href="//plstyle.cn/2018/08/07/blog_code_readability/"/>
    <id>//plstyle.cn/2018/08/07/blog_code_readability/</id>
    <published>2018-08-07T04:00:00.000Z</published>
    <updated>2018-08-07T11:42:46.368Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要就是一些对代码可读性方面的一些见解与总结<br><a id="more"></a></p><h2 id="可读性的重要性"><a href="#可读性的重要性" class="headerlink" title="可读性的重要性"></a>可读性的重要性</h2><p>编程有很多时间都在阅读代码，不仅要阅读自己的代码，还要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。并且，可读性良好的代码往往会让架构更好，因为程序员更愿意去修改这部分代码，也更容易修改。只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p><h2 id="可读性的体现"><a href="#可读性的体现" class="headerlink" title="可读性的体现"></a>可读性的体现</h2><p>代码可读性体现在编码设计的各个方面，包括命名、注释以及逻辑等，接下来一一进行介绍：</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>命名一方面得表达代码含义，比如find、start、search等一些表达力比较强的单词，别人一看就知道是什么含义，当然组合词也是很常见的，比如findItem、startThread等；另一方面是不能包含歧义，起的名字不能让人产生歧义，可以适当加一些前缀（is、has）和一些后缀(able)来增强语义表达。比如</p><ul><li>用 min、max 表示数量范围；</li><li>用 first、last 表示访问空间的包含范围；</li><li>begin、end 表示访问空间的排除范围，即 end 不包含尾部</li></ul><h3 id="良好的代码风格"><a href="#良好的代码风格" class="headerlink" title="良好的代码风格"></a>良好的代码风格</h3><p>添加适当的缩进与换行来增强代码可读性；提高代码以及注释排列的整齐性；代码语句不能随意改变顺序，虽然可能不会影响结果，但是可读性更差，对于自己或者他人在日后阅读这块代码的时候增加了难度。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和setter方法，为这些方法写注释反而让代码可读性更差。 </p><p>当然，不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p><p>注释用来提醒一些特殊情况：</p><ul><li><em>TODO</em>——待做</li><li><em>FIXME</em>——待修复</li><li><em>HACK</em>——粗糙的解决方案</li><li><em>XXX</em>——危险！这里有重要的问题</li></ul><p>在java中可利用一些ide配置一些注释模板，写起注释更加得方便，不同的ide配置方式也不同，这里就不进行介绍了</p><h3 id="控制流的可读性"><a href="#控制流的可读性" class="headerlink" title="控制流的可读性"></a>控制流的可读性</h3><p>控制流的可读性说明白点就是对一些逻辑控制的可读性，业务开发过程中，逻辑控制是肯定避免不了。对于自己开发的代码，一段时间后再去看，如果逻辑被你写得“很复杂”，那估计也是很头痛的事，要是别人去看的话，估计想哭的心情都有了，所以逻辑控制的清晰度也是很重要的。</p><p>在java方面：</p><ul><li>尽量少用三目运算符(tag？a:b)，因为它看起来更不容易让人理解,可以用if/else来替换；</li><li>尽量用while来代替do/while，因为do/while的条件在后面，不够简单明了；</li><li>在循环嵌套语句中，尽量使用return、break以及continue来减少嵌套层数；</li><li>拆分长表达式也是很重要的，如果一些控制条件的表达式很长并且括号很多，相信一定是很头疼的事。所以拆分长表达是必不可少的，拆分可以分为两部分，一个是单纯用变量替换子表达式，另一个是可以结合逻辑运算符来使表达式逻辑更加清晰，两者结合起来使用效果更加。</li><li>减少变量的作用域，一个变量的作用域在满足需求的条件下是越小越好，当对其做修改时，影响的地方最好时一眼就能看出来，这样修改扩展就方便了。当一个变量作用域很大的时候，比如公有的全局静态变量（public static String temp），当你或者他人对其进行修改，造成的影响可想而知，因为所有的地方都能调用与使用。</li></ul><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>在java层面，这个原则尤为主要，不管是类还是方法还是属性，他们应该都是单一职责的，他们只负责某一项任务或者事情，只做一件事很容易让人知道它要做的事情。</p><p>任何大项目或者大工程都是由一件件小流程或者小事物组成，之所以有些项目star多，更受人学习推崇，是因为他们在事物拆分以及任务划分方面做的更好，整个代码结构更加的清晰，可读性更高，大家更愿意去学习。</p><h3 id="设计简单为主"><a href="#设计简单为主" class="headerlink" title="设计简单为主"></a>设计简单为主</h3><p>一开始不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的，多用标准库实现。当然还是得尽量遵从对扩展是开放，对修改是禁止的原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要就是一些对代码可读性方面的一些见解与总结&lt;br&gt;
    
    </summary>
    
    
      <category term="可读性" scheme="//plstyle.cn/tags/%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
      <category term="代码" scheme="//plstyle.cn/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之——六大设计原则</title>
    <link href="//plstyle.cn/2018/07/19/blog_pattern_principio/"/>
    <id>//plstyle.cn/2018/07/19/blog_pattern_principio/</id>
    <published>2018-07-19T04:00:00.000Z</published>
    <updated>2018-07-19T11:35:07.229Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要就是介绍面向对象设计过程中六个编码原则<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>作为一个程序员，在日常的编码工程中，多多少少都会接触和使用到设计模式以及设计原则，特别是面向对象编程（java、C++以及C#等），在合适的场合去运用它们，往往能事半功倍。</p><h3 id="面向过程设计"><a href="#面向过程设计" class="headerlink" title="面向过程设计"></a>面向过程设计</h3><p>就是将要实现一个功能所需要的步骤一步一步的写出来，要做到面面俱到、有条不絮</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>面向对象就是将面向过程的代码进行封装，并将其核心的参数抽象化，使其可以复用，从而减少代码量的一个模式，面向对象不是面向过程的代替，而是面向过程的封装。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结，是专门用于解决特定场景的一种模式或者架构。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>任何事物都有设计原则，编程也不例外，在面向对象的设计过程中，设计原则就是为了约束你的编码与设计，以便能更符合更有利于程序的扩展以及容错。</p><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><h3 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改一个类的原因应该只有一个。</span><br></pre></td></tr></table></figure><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类应该对扩展开放，对修改关闭。</span><br></pre></td></tr></table></figure><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类对象必须能够替换掉所有父类对象。</span><br></pre></td></tr></table></figure><p>继承是一种 IS-A关系，子类需要能够当成父类来使用，并且需要比父类更特殊。如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不应该强迫客户依赖于它们不用的方法。</span><br></pre></td></tr></table></figure><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</span><br></pre></td></tr></table></figure><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序的组织架构设计开始就得考虑设计原则，并且设计原则始终贯穿于你的日常编码中，所以要时刻警醒并且尽最大努力去遵循（虽然有时候确实没办法做到），这是一个好程序的必备条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要就是介绍面向对象设计过程中六个编码原则&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="//plstyle.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="//plstyle.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava2学习总结</title>
    <link href="//plstyle.cn/2018/07/17/blog_rxjava2/"/>
    <id>//plstyle.cn/2018/07/17/blog_rxjava2/</id>
    <published>2018-07-17T04:00:00.000Z</published>
    <updated>2018-07-17T02:54:54.743Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要就是对Rxjava2的学习总结<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>对于Rxjava1与Rxjava2之前在项目中多少都使用过，由于Rxjava1与Rxjava2并无继承关系，后者在背压支持上更优秀且前者已经不再维护，所以着重介绍Rxjava2。</p><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><p>函数响应式编程是函数式编程和响应式编程这两大颠覆传统的牛逼编程范式叠加后的产物，编程界的牛逼二次方。</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>是一种通过函数或者函数组合调用来处理数据，获取结果的编程范式。</p><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>是一种面向数据流以及变化传播的一种范式，其中变化传播在程序中也是转换为数据流的形式进行处理。</p><h4 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h4><p>是一种通过一系列的函数组合调用来发射、转变以及监听，响应数据流的编程范式。在RxJava中，函数响应式编程具体表现为一个观察者（Observer）订阅一个可观察对象（Observable），通过创建可观察对象发射数据流，经过一系列操作符（Operators）加工处理和线程调度器（Scheduler）在不同线程间的转发，最后由观察者接受并做出响应的一个过程。</p><p>在RxJava2中，提供了五对观察者模式组合来完成这一系列的过程，每一对组合依靠其可调用的一系列函数的差异，而具有各自的特点。这五类组合（前为可观察对象后为对应的观察者）分别是：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一组：ObservableSource/Observer</span><br><span class="line">一次可发送单条数据或者数据序列<span class="keyword">on</span>Next，可发送完成通知<span class="keyword">on</span>Complete或异常通知<span class="keyword">on</span>Error，不支持背压。</span><br><span class="line"></span><br><span class="line">第二组：Publisher/Subscriber</span><br><span class="line">第一组基础上进行改进，支持背压，一次可发送单条数据或者数据序列<span class="keyword">on</span>Next，可发送完成通知<span class="keyword">on</span>Complete或异常通知<span class="keyword">on</span>Error，但效率没有第一组高。</span><br><span class="line"></span><br><span class="line">第三组：SingleSource/SingleObserver</span><br><span class="line">第一组简化版，只能发送单条数据<span class="keyword">on</span>Success，或者异常通知<span class="keyword">on</span>Error</span><br><span class="line"></span><br><span class="line">第四组：CompletableSource/CompletableObserve</span><br><span class="line">第一组简化版，不能发送数据，只发送完成通知<span class="keyword">on</span>Complete或者异常通知<span class="keyword">on</span>Error</span><br><span class="line"></span><br><span class="line">第五组：MaybeSource/MaybeObserver</span><br><span class="line">第三，第四组的合并版，只能发送单条数据<span class="keyword">on</span>Success和完成通知<span class="keyword">on</span>Complete或者发送一条异常通知<span class="keyword">on</span>Error</span><br></pre></td></tr></table></figure><h2 id="Rxjava2使用介绍"><a href="#Rxjava2使用介绍" class="headerlink" title="Rxjava2使用介绍"></a>Rxjava2使用介绍</h2><p>先来一波代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察者</span></span><br><span class="line">        Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                e.onNext(<span class="string">"hello world"</span>)  <span class="comment">//执行observer的onNext()回调方法</span></span><br><span class="line">                e.onNext(<span class="string">"hello world"</span>);</span><br><span class="line">                e.onComplete();<span class="comment">//执行onComplete()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//观察者</span></span><br><span class="line">        Observer observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//Disposable是观察者Observer与可观察对象Observable建立订阅关系后生成的用来取消订阅关系和判断订阅关系是否存在的一个接口。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//默认执行的方法,无调用限制</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//发送异常通知，只会执行一次与onComplete互斥,不在执行后面的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//发送完成通知，只会执行一次与onError互斥,不在执行后面的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//绑定形成订阅关系</span></span><br><span class="line">        observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p><p>rxjava2与rxjava1一样都是基于观察者模式，所以会包含观察者与被观察者，被观察者（Observable/Flowable）通过发送事件告知（订阅的关系）观察者然后观察者进行消费操作，这就是最简单的一个流程。</p><p>以上注释都很清楚，就不多说了，需要说明的一点是如果调用Disposable的dispose()方法解除绑定，对于被观察者发送事件是没影响的，只不过Observer是不会再消费后面的事件了。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>操作符（Operators）：其实质是函数式编程中的高阶函数，是对响应式编程的各个过程拆分封装后的产物，以便于我们操作数据流。</p><p>操作符大致可以分为一下几个类别，以下将对常用的几个操作符作介绍:</p><h4 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Observable，可接受一个或多个参数，将每个参数逐一发送</span></span><br><span class="line">        Observable.just(<span class="string">"hello world"</span>).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(s);  <span class="comment">//打印hello world</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//fromArray:创建一个Observable，接受一个数组，并将数组中的数据逐一发送</span></span><br><span class="line">        <span class="comment">//fromIterable：&lt;/b&gt;创建一个Observable，接受一个可迭代对象，并将可迭代对象中的数据逐一发送</span></span><br><span class="line">        <span class="comment">//range：&lt;/b&gt;创建一个Observable，发送一个范围内的整数序列</span></span><br><span class="line">        <span class="comment">//Observable.range(1,10);//从1开始以步长1递增发送10个数据</span></span><br><span class="line">        Observable.range(<span class="number">0</span>,<span class="number">5</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(integer); <span class="comment">//依次打印0-5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter：filter使用Predicate 函数接口传入条件值，来判断Observable发射的每一个值是否满足这个条件，如果满足，则继续向下传递，如果不满足，则过滤掉。</span></span><br><span class="line">       Observable.range(<span class="number">0</span>,<span class="number">10</span>).filter(<span class="literal">new</span> Predicate&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="built_in">boolean</span> test(<span class="built_in">Integer</span> <span class="built_in">integer</span>) throws Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">integer</span> % <span class="number">3</span> == <span class="number">0</span>;  <span class="comment">//判断条件  为true则传递给Observer</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(<span class="literal">new</span> Consumer&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="literal">void</span> accept(<span class="built_in">Integer</span> <span class="built_in">integer</span>) throws Exception &#123;</span><br><span class="line">               System.out.println(<span class="built_in">integer</span>);  <span class="comment">//打印0，3，6，9</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//distinct:过滤掉重复的数据项，过滤规则为：只允许还没有发射过的数据项通过。</span></span><br><span class="line">       Observable.just(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>).distinct().subscribe(<span class="literal">new</span> Consumer&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="literal">void</span> accept(<span class="built_in">Integer</span> <span class="built_in">integer</span>) throws Exception &#123;</span><br><span class="line">               System.out.println(<span class="built_in">integer</span>);  <span class="comment">//打印1，2，3，4，5</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//当然也可以将filter与distinct进行组合链式使用</span></span><br><span class="line">       Observable.just(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).distinct().filter(<span class="literal">new</span> Predicate&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="built_in">boolean</span> test(<span class="built_in">Integer</span> <span class="built_in">integer</span>) throws Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">integer</span> % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(<span class="literal">new</span> Consumer&lt;<span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="literal">void</span> accept(<span class="built_in">Integer</span> <span class="built_in">integer</span>) throws Exception &#123;</span><br><span class="line">               System.out.println(<span class="built_in">integer</span>);  <span class="comment">//3，6</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h4 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//map:对Observable发射的每一项数据应用一个函数，执行变换操作</span><br><span class="line">       //map操作符，需要接收一个函数接口<span class="function"><span class="keyword">Function</span></span>&lt;T,R&gt;的实例化对象，实现接口内R apply(T t)的方法，在此方法中可以对接收到的数据t进行变换后返回。</span><br><span class="line">      Observable.<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>).map(new <span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>, String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          <span class="keyword">public</span> String apply(<span class="keyword">Integer</span> <span class="keyword">integer</span>) throws Exception &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"item:"</span>+<span class="keyword">integer</span> * <span class="keyword">integer</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          <span class="keyword">public</span> void accept(String s) throws Exception &#123;</span><br><span class="line">              System.<span class="keyword">out</span>.println(s); //打印item:<span class="number">0</span>，item:<span class="number">1</span>，item:<span class="number">4</span>，item:<span class="number">9</span>，item:<span class="number">16</span>，item:<span class="number">25</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      //flatMap:将一个发射数据的Observable变换为多个Observable，然后将多个Observable发射的数据合并到一个Observable中进行发射</span><br><span class="line">       <span class="keyword">Integer</span>[] num1 = new <span class="keyword">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">       <span class="keyword">Integer</span>[] num2 = new <span class="keyword">Integer</span>[]&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="keyword">Integer</span>[] num3 = new <span class="keyword">Integer</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">       Observable.just(num1, num2, num3).flatMap(new <span class="function"><span class="keyword">Function</span></span>&lt;<span class="keyword">Integer</span>[], Observable&lt;<span class="keyword">Integer</span>&gt;&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> Observable&lt;<span class="keyword">Integer</span>&gt; apply(<span class="keyword">Integer</span>[] integers) throws Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> Observable.fromArray(integers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(new Consumer&lt;<span class="keyword">Integer</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> void accept(<span class="keyword">Integer</span> <span class="keyword">integer</span>) throws Exception &#123;</span><br><span class="line">               System.<span class="keyword">out</span>.println(<span class="keyword">integer</span>); //依次打印<span class="number">1</span>-<span class="number">9</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h4 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mergeWith：合并多个Observable发射的数据，可能会让Observable发射的数据交错。</span></span><br><span class="line">       Integer []num4 = new Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       Observable.just(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>).mergeWith(Observable.fromArray(num4)).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer <span class="type">integer</span>) throws Exception &#123;</span><br><span class="line">               System.out.println(<span class="type">integer</span>);  <span class="comment">//打印1,2,3,5,6,4,7,8  可能会发生错乱</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//concatWith：同mergeWith一样，用以合并多个Observable发射的数据，但是concatWith不会让Observable发射的数据交错。</span></span><br><span class="line">       Integer []num5 = new Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       Observable.just(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>).concatWith(Observable.fromArray(num4)).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer <span class="type">integer</span>) throws Exception &#123;</span><br><span class="line">               System.out.println(<span class="type">integer</span>);  <span class="comment">//打印1,2,3,4,5,6,7,8 不会错乱</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h4 id="聚合操作符"><a href="#聚合操作符" class="headerlink" title="聚合操作符"></a>聚合操作符</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zipWith：将多个Obversable发射的数据，通过一个函数BiFunction对对应位置的数据处理后放到一个新的Observable中发射，所发射的数据个数与最少的Observabel中的一样多。</span></span><br><span class="line">       <span class="keyword">String</span> []colors = <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;<span class="string">"黄色"</span>,<span class="string">"红色"</span>,<span class="string">"绿色"</span>,<span class="string">"橙色"</span>,<span class="string">"褐色"</span>,<span class="string">"黑色"</span>&#125;;</span><br><span class="line">       Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>).zipWith(Observable.fromArray(colors), <span class="keyword">new</span> BiFunction&lt;Integer, <span class="keyword">String</span>, <span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">String</span> apply(Integer integer, <span class="keyword">String</span> s) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> integer + s;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> accept(<span class="keyword">String</span> s) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(s);  <span class="comment">//打印1黄色 2红色 3绿色...6黑色</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="Scheduler线程调度器"><a href="#Scheduler线程调度器" class="headerlink" title="Scheduler线程调度器"></a>Scheduler线程调度器</h3><p>Scheduler(线程调度器)赋予RxJava简洁明了的异步操作,可以说是RxJava中最值得称道的地方。Scheduler(线程调度器)可以让RxJava的线程切换变得简单明了，即使程序逻辑变得十分复杂，他依然能够保持简单明了。</p><h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;T&gt; subscribeOn(<span class="name">Scheduler</span> scheduler)</span><br></pre></td></tr></table></figure><p>subscribeOn通过接收一个Scheduler参数，来指定对数据的处理运行在特定的线程调度器Scheduler上。若多次设定，则只有一次起作用。</p><h4 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;T&gt; observeOn(<span class="name">Scheduler</span> scheduler)</span><br></pre></td></tr></table></figure><p>observeOn同样接收一个Scheduler参数，来指定下游操作运行在特定的线程调度器Scheduler上。若多次设定，每次均起作用。</p><h4 id="Scheduler种类"><a href="#Scheduler种类" class="headerlink" title="Scheduler种类"></a>Scheduler种类</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Schedulers</span><span class="selector-class">.io</span>():用于<span class="selector-tag">IO</span>密集型的操作，例如读写<span class="selector-tag">SD</span>卡文件，查询数据库，访问网络.</span><br><span class="line"><span class="selector-tag">Schedulers</span><span class="selector-class">.newThread</span>()：在每执行一个任务时创建一个新的线程，不具有线程缓存机制，因为创建一个新的线程比复用一个线程更耗时耗力，虽然使用<span class="selector-tag">Schedulers</span><span class="selector-class">.io</span>()的地方，都可以使用<span class="selector-tag">Schedulers</span><span class="selector-class">.newThread</span>()，但是，<span class="selector-tag">Schedulers</span><span class="selector-class">.newThread</span>()的效率没有<span class="selector-tag">Schedulers</span><span class="selector-class">.io</span>()高。</span><br><span class="line"><span class="selector-tag">Schedulers</span><span class="selector-class">.computation</span>()：用于<span class="selector-tag">CPU</span> 密集型计算任务，即不会被 <span class="selector-tag">I</span>/<span class="selector-tag">O</span> 等操作限制性能的耗时操作，</span><br><span class="line"><span class="selector-tag">Schedulers</span><span class="selector-class">.trampoline</span>()：在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。</span><br><span class="line"><span class="selector-tag">Schedulers</span><span class="selector-class">.single</span>()：拥有一个线程单例，所有的任务都在这一个线程中执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。</span><br><span class="line"><span class="selector-tag">AndroidSchedulers</span><span class="selector-class">.mainThread</span>()：在<span class="selector-tag">Android</span> <span class="selector-tag">UI</span>线程中执行任务，为<span class="selector-tag">Android</span>开发定制。</span><br><span class="line"><span class="selector-tag">Scheduler</span><span class="selector-class">.from</span>(<span class="variable">@NonNull</span> Executor executor)：指定一个线程调度器，由此调度器来控制任务的执行策略。</span><br></pre></td></tr></table></figure><p>以上列出的是rxjava2中所有支持的Scheuler种类，Rxjava1中Schedulers.immediate()被Schedulers.trampoline()替换。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="variable">@Override</span></span><br><span class="line">           public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                <span class="keyword">for</span>(int i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"发射线程:"</span>+Thread.currentThread().getName()+<span class="string">"---&gt;发射"</span>+i);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    e.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                e.onComplete();</span><br><span class="line">           &#125;</span><br><span class="line">          &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">               .map(new Function&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                   <span class="variable">@Override</span></span><br><span class="line">                   public Integer apply(Integer integer) throws Exception &#123;</span><br><span class="line">                       System.out.println(<span class="string">"处理线程:"</span>+Thread.currentThread().getName()+<span class="string">"---&gt;处理"</span>+integer);</span><br><span class="line">                       <span class="keyword">return</span> integer;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                   <span class="variable">@Override</span></span><br><span class="line">                   public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                       System.out.println(<span class="string">"接收线程:"</span>+Thread.currentThread().getName()+<span class="string">"---&gt;接收"</span>+integer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               </span><br><span class="line">/<span class="regexp">/运行结果如下</span></span><br><span class="line"><span class="regexp">System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:0</span></span><br><span class="line"><span class="regexp">System.out: 处理线程:RxCachedThreadScheduler-1----&gt;处理:0</span></span><br><span class="line"><span class="regexp">System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:1</span></span><br><span class="line"><span class="regexp">System.out: 接收线程:main----&gt;接收:0</span></span><br><span class="line"><span class="regexp">System.out: 处理线程:RxCachedThreadScheduler-1----&gt;处理:1</span></span><br><span class="line"><span class="regexp">System.out: 接收线程:main----&gt;接收:1</span></span><br></pre></td></tr></table></figure><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>从上可知，数据流的发射、处理以及响应可能在各自线程中独立进行，上游的发射数据的时候，不知道下游是否处理完，所以会产生一种情况，发送事件的速度大于消费事件的速度，这样就会产生很多待处理的数据，不会被垃圾回收机制回收，而是存放在一个异步的缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是背压问题。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   e.onNext(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               System.out.println(integer);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><p>创建一个可观察对象Obervable在Schedulers.newThread()()的线程中不断发送数据，而观察者Observer在Schedulers.newThread()的另一个线程中每隔3秒接收一条数据，运行后，查看内存使用如下图：</p><p><img src="/img/pl/rxjava2_backpressure.gif" alt=""></p><p>由于上下游分别在各自的线程中独立处理数据（如果上下游在同一线程中，下游对数据的处理会堵塞上游数据的发送，上游发送一条数据后会等下游处理完之后再发送下一条），而上游发送数据速度远大于下游接收数据的速度，造成上下游流速不均，导致数据累计，最后引起内存溢出。</p><h4 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h4><p>Flowable是为了解决背压（backpressure）问题，而在Observable的基础上优化后的产物，与Observable不是同一组观察者模式下的成员，Flowable是Publisher与Subscriber这一组观察者模式中Publisher的典型实现，Observable是ObservableSource/Observer这一组观察者模式中ObservableSource的典型实现。</p><p>既然Flowable是在Observable的基础上优化后的产物，Observable能解决的问题Flowable都能进行解决，何不抛弃Observable而只用Flowable呢。其实，这是万万不可的，他们各有自己的优势和不足。由于基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。</p><p>因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。<br>所以，如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用Flowable，以免影响性能。</p><h4 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h4><p>Flowable的异步缓存池不同于Observable，Observable的异步缓存池没有大小限制，可以无限制向里添加数据，直至OOM,而Flowable的异步缓存池有个固定容量，其大小为128。<br>BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池存储数据的策略。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ERROR</span>:在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。</span><br><span class="line"></span><br><span class="line"><span class="attribute">DROP</span>:在此策略下，如果Flowable的异步缓存池满了，会丢掉将要放入缓存池中的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">BUFFER</span>:此策略下，Flowable的异步缓存池同Observable的一样，没有固定大小，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM。</span><br><span class="line"></span><br><span class="line"><span class="attribute">MISSING</span>:此策略表示，通过Create方法创建的Flowable没有指定背压策略，不会对通过OnNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</span><br><span class="line"></span><br><span class="line"><span class="attribute">LATEST</span>:与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，LATEST都会将最后一条数据强行放入缓存池中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="variable">@Override</span></span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                for(int i = <span class="number">0</span>; i&lt;<span class="number">500</span>; i++)&#123;</span><br><span class="line">                    e.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//具体背压策略替换这里即可</span></span><br><span class="line">        &#125;, BackpressureStrategy.BUFFER)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="variable">@Override</span></span><br><span class="line">                    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                        System.out.println(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//onBackpressureXXX背压操作符</span></span><br><span class="line">        <span class="comment">//Flowable除了通过create创建的时候指定背压策略，也可以在通过其它创建操作符just，fromArray等创建后通过背压操作符指定背压策略。</span></span><br><span class="line">        <span class="comment">//onBackpressureBuffer()对应BackpressureStrategy.BUFFER</span></span><br><span class="line">        <span class="comment">//onBackpressureDrop()对应BackpressureStrategy.DROP</span></span><br><span class="line">        <span class="comment">//onBackpressureLatest()对应BackpressureStrategy.LATEST</span></span><br><span class="line">        <span class="comment">//这个与上面Flowable.create()方式创建效果是一样的</span></span><br><span class="line">        <span class="selector-tag">Flowable</span><span class="selector-class">.range</span>(<span class="number">0</span>, <span class="number">500</span>)</span><br><span class="line">                <span class="selector-class">.onBackpressureBuffer</span>()</span><br><span class="line">                <span class="selector-class">.subscribeOn</span>(Schedulers.newThread())</span><br><span class="line">                <span class="selector-class">.observeOn</span>(Schedulers.newThread())</span><br><span class="line">                <span class="selector-class">.subscribe</span>(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="variable">@Override</span></span><br><span class="line">                    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>所以结合FlowableEmitter与Subscription，通过设置处理请求量(subscription.request)以及动态获取待处理请求量(FlowableEmitter.requested())，对Flowable做出改进，让其不会产生背压问题，也不会引起异常或者数据丢失。代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                   <span class="comment">//e.requested()获取下游未处理的事件量</span></span><br><span class="line">                   <span class="keyword">if</span>(e.requested() == <span class="number">0</span>) <span class="keyword">continue</span>;   <span class="comment">//此处添加代码，让Flowable按需添加代码</span></span><br><span class="line">                   System.out.println(<span class="string">"发射---&gt;"</span>+i);</span><br><span class="line">                   i++;</span><br><span class="line">                   e.onNext(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, BackpressureStrategy.MISSING)</span><br><span class="line">               .subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                   Subscription subscription;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">                      <span class="comment">//s.request设置可处理的事件量，默认为0不进行处理</span></span><br><span class="line">                       s.request(<span class="number">1</span>);   <span class="comment">//设置初始请求数据为1</span></span><br><span class="line">                       subscription = s;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                           System.out.println(<span class="string">"接收---&gt;"</span>+integer);</span><br><span class="line">                           subscription.request(<span class="number">1</span>);<span class="comment">//每接收到一条请求就增加一条请求量</span></span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Observable简化版之Single、Comoplable以及Maybe"><a href="#Observable简化版之Single、Comoplable以及Maybe" class="headerlink" title="Observable简化版之Single、Comoplable以及Maybe"></a>Observable简化版之Single、Comoplable以及Maybe</h3><p>在Rxjava2中，Observale和Flowable都是用来发射数据流的，但是，我们在实际应用中，很多时候，需要发射的数据并不是数据流的形式，而只是一条单一的数据，或者一条完成通知，或者一条错误通知。在这种情况下，我们再使用Observable或者Flowable就显得有点大材小用，于是，为了满足这种单一数据或通知的使用场景，便出现了Observable的简化版——Single、Completable、Maybe。</p><h4 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h4><p>只发射一条单一的数据，或者一条异常通知，不能发射完成通知，其中数据与通知只能发射一个。</p><h4 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h4><p>只发射一条完成通知，或者一条异常通知，不能发射数据，其中完成通知与异常通知只能发射一个</p><h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>可发射一条单一的数据，以及发射一条完成通知，或者一条异常通知，其中完成通知和异常通知只能发射一个，发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。</p><p>三者的调用方式与Observable类似，只是create方法中传递的对象不同而已，由于篇幅有限，这边就不给出代码示例，具体可参考：<a href="https://www.jianshu.com/p/66a55abbadef" target="_blank" rel="noopener">https://www.jianshu.com/p/66a55abbadef</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于Rxjava2学习总结，关于背压这块我介绍的可能不是很清楚，可参照以下博客。</p><p>背压介绍：<a href="https://www.jianshu.com/p/ff8167c1d191" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8167c1d191</a></p><p>示例代码：<a href="https://github.com/penglian/Rxjava2Demo/" target="_blank" rel="noopener">https://github.com/penglian/Rxjava2Demo/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要就是对Rxjava2的学习总结&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="Rxjava2" scheme="//plstyle.cn/tags/Rxjava2/"/>
    
      <category term="响应函数式" scheme="//plstyle.cn/tags/%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="背压" scheme="//plstyle.cn/tags/%E8%83%8C%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>解决部分机型(三星、魅族)相机拍摄图片倒向问题</title>
    <link href="//plstyle.cn/2018/07/16/blog_camera_update_down/"/>
    <id>//plstyle.cn/2018/07/16/blog_camera_update_down/</id>
    <published>2018-07-16T04:00:00.000Z</published>
    <updated>2018-07-16T08:15:32.798Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要是解决部分机型（三星以及魅族部分机型）上，调用原生的相机拍摄图片倒向的问题<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>近来在项目中遇到一个问题是部分机型调用原生相机拍摄的照片倒向了，经过测试反应大部分机型是没问题，只会在三星与个别的魅族机型上出现。看到这个一般就知道是rom定制化搞的鬼了，Android是个开源的生态系统，各个手机厂商会根据自己的需求去修改framework、c++甚至底层的代码，这就导致了市面上千奇百怪的“Android手机”了，相对于IOS开发来说，Android开发者需要在兼容性上多下功夫了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>一切bug与缺陷只要定位到问题，一般来说就解决一半了，剩下的就是看你采用哪种解决方式了。就算你解决不了，一般也能启动弥补方案或者尽量去避开它，当然这种情况一般是很少见的，毕竟网络是只有你想不到没有它做不到的。</p><h3 id="Exif-ExifInterface简介"><a href="#Exif-ExifInterface简介" class="headerlink" title="Exif-ExifInterface简介"></a>Exif-ExifInterface简介</h3><p>Exif是一种图像文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及GPS全球定位系统数据、缩略图等。</p><h3 id="ExifInterface中的功能简单进行介绍"><a href="#ExifInterface中的功能简单进行介绍" class="headerlink" title="ExifInterface中的功能简单进行介绍"></a>ExifInterface中的功能简单进行介绍</h3><p>Android开发中，在对图片进行展示、编辑、发送等操作时经常会涉及Exif的操作，Android中操作Exif主要是通过ExifInterface，ExifInterface看上去是一个接口，其实是一个类，位于Android.media.ExifInterface的位置。进入ExifInterface类，发现方法很少，主要就是三个方面：读取、写入、缩略图。</p><p>所以根据以上介绍可知，我们可以根据exif获取拍摄图片的旋转角度的信息再结合Matrix进行矩阵转换生成bitmap即可，代码如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取照片exif信息中的旋转角度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> path 照片路径</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>角度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> readPictureDegree(String path) &#123;</span><br><span class="line">       <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ExifInterface exifInterface = <span class="keyword">new</span> ExifInterface(path);</span><br><span class="line">           <span class="keyword">int</span> orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">           <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">               <span class="keyword">case</span> ExifInterface.<span class="string">ORIENTATION_ROTATE_90:</span></span><br><span class="line">                   degree = <span class="number">90</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> ExifInterface.<span class="string">ORIENTATION_ROTATE_180:</span></span><br><span class="line">                   degree = <span class="number">180</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> ExifInterface.<span class="string">ORIENTATION_ROTATE_270:</span></span><br><span class="line">                   degree = <span class="number">270</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> degree;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 旋转角度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> img</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> degree</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bitmap turnToDegree(Bitmap img, <span class="keyword">int</span> degree)&#123;</span><br><span class="line">       Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">       matrix.postRotate(degree);</span><br><span class="line">       <span class="keyword">int</span> width = img.getWidth();</span><br><span class="line">       <span class="keyword">int</span> height =img.getHeight();</span><br><span class="line">       img = Bitmap.createBitmap(img, <span class="number">0</span>, <span class="number">0</span>, width, height, matrix, <span class="literal">true</span>);</span><br><span class="line">       <span class="keyword">return</span> img;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>相机调用以及文件保存代码中就不体现了，以上有两个方法，一个是检测旋转角度的，另外一个是根据旋转角度进行图像旋转的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于这种厂商rom定制化产生的问题，只能是遇到一个解决一个，因为你无法预知那些厂商的心思，只能不断去积累经验。还有当无法解决的时候，有选择的话尽量避开，否则能进行异常捕获的，尽量去捕获，避免造成crash。当然具体问题还得具体分析，不能一概而论。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要是解决部分机型（三星以及魅族部分机型）上，调用原生的相机拍摄图片倒向的问题&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="camera" scheme="//plstyle.cn/tags/camera/"/>
    
      <category term="三星" scheme="//plstyle.cn/tags/%E4%B8%89%E6%98%9F/"/>
    
      <category term="魅族" scheme="//plstyle.cn/tags/%E9%AD%85%E6%97%8F/"/>
    
      <category term="ExifInterface" scheme="//plstyle.cn/tags/ExifInterface/"/>
    
  </entry>
  
  <entry>
    <title>长截图并且保存到图库</title>
    <link href="//plstyle.cn/2018/07/12/blog_screenshot_save/"/>
    <id>//plstyle.cn/2018/07/12/blog_screenshot_save/</id>
    <published>2018-07-12T04:00:00.000Z</published>
    <updated>2018-07-12T12:08:00.220Z</updated>
    
    <content type="html"><![CDATA[<hr><p>主要讲述的是长截图的实现以及保存图片通知图库更新。<br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>由于项目需求，需要实现一个长截图保存并且通知图库更新的需求，便好好研究了一下。首先，这是两个功能点，一个是实现自定义的长截图，另一个是保存图片并且通知图库更新，后者相对来说比较简单，前者则需要一些“黑科技”。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><p>首先，得明确需求，只有理解好了需求，才能在设计程序的过程中，去兼顾通用性与扩展性，而不能拘泥于当前的需求实现。长截图的实现包括短截图、全屏截图以及长截图，所以得实现一个能自定义视图的截图方式，兼容各个方式的截图实现。图片保存并且通知图库更新，这个主要是要考虑到Android版本对于通知图库更新这块的差异，判断版本号分开处理。</p><h3 id="长截图实现"><a href="#长截图实现" class="headerlink" title="长截图实现"></a>长截图实现</h3><p>这块资料在网上相对较少，一般都是全屏截图，或者是针对ListView或者ScrollView的比较复杂的实现，不通用也不简易，肯定是不可取的，所以只能放弃以上这些方式。黄天不负有心人，经过不懈的努力，终于找到了一个黑科技，简洁高效，实现代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 截取指定区域bitmap</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param view 截取区域的view</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public <span class="keyword">Bitmap </span>getScreenShotsBitmap(View view)</span><br><span class="line">               <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">Bitmap.createBitmap(v.getWidth(), </span>v.getHeight(), <span class="built_in">Config</span>.RGB_565)<span class="comment">;</span></span><br><span class="line">               final Canvas canvas = new Canvas(<span class="keyword">bitmap);</span></span><br><span class="line"><span class="keyword"> </span>              v.draw(canvas)<span class="comment">;</span></span><br><span class="line">               return <span class="keyword">bitmap;</span></span><br><span class="line"><span class="keyword"> </span>  &#125;</span><br></pre></td></tr></table></figure></p><p>代码很简洁，只需要传递一个view，然后创建一个bitmap，用bitmap去创建canvas，然后调用view.draw(canvas)即可，返回的bitmap就是想要结果。</p><h3 id="保存图片并且通知图库更新"><a href="#保存图片并且通知图库更新" class="headerlink" title="保存图片并且通知图库更新"></a>保存图片并且通知图库更新</h3><p>保存图片到SD卡并且通知图库更新，使得用户打开图库就能看到你刚刚保存的图片，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"> * 截屏保存到图库</span><br><span class="line"> *</span><br><span class="line"> * @param activity</span><br><span class="line"> * @param successMsg</span><br><span class="line"> * @param errorMsg</span><br><span class="line"> * @param o</span><br><span class="line"> */</span><br><span class="line">public void storeScreenShot(Activity activity, String successMsg, String errorMsg, View view)&#123;</span><br><span class="line">    Bitmap bitmap = getScreenShotsBitmap(o);</span><br><span class="line">    if (bitmap == null) &#123;</span><br><span class="line">        ToastUtils.showLongToast(activity, errorMsg);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveImageToGallery(activity, bitmap, successMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 保存图片到图库</span><br><span class="line"> *</span><br><span class="line"> * @param context</span><br><span class="line"> * @param message</span><br><span class="line"> * @param bmp</span><br><span class="line"> */</span><br><span class="line">private void saveImageToGallery(Context context, Bitmap bmp, String message) &#123;</span><br><span class="line">    // 首先保存图片</span><br><span class="line">    File appDir = new File(Environment.getExternalStorageDirectory(), &quot;cib&quot;);</span><br><span class="line">    if (!appDir.exists()) &#123;</span><br><span class="line">        appDir.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String fileName = System.currentTimeMillis() + &quot;.jpg&quot;;</span><br><span class="line">    File file = new File(appDir, fileName);</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">        bmp.compress(CompressFormat.JPEG, 100, fos);</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其次把文件插入到系统图库</span><br><span class="line">    try &#123;</span><br><span class="line">        MediaStore.Images.Media.insertImage(context.getContentResolver(),</span><br><span class="line">                file.getAbsolutePath(), fileName, null);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最后通知图库更新</span><br><span class="line">    refreshPicture(context, file.getAbsolutePath(), message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 浏览图片</span><br><span class="line"> *</span><br><span class="line"> * @param filePath</span><br><span class="line"> * @param context</span><br><span class="line"> */</span><br><span class="line">public void scanPhotos(String filePath, Context context) &#123;</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">    Uri uri = Uri.fromFile(new File(filePath));</span><br><span class="line">    intent.setData(uri);</span><br><span class="line">    context.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在4.4以上，google规定了不允许第三方应用向系统发送广播，所以4.4以上需要采用MediaScannerConnection来实现</span><br><span class="line"> *</span><br><span class="line"> * @param context</span><br><span class="line"> * @param filePath</span><br><span class="line"> * @param message</span><br><span class="line"> */</span><br><span class="line">private void refreshPicture(final Context context, String filePath, String message) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">        MediaScannerConnection.scanFile(context,</span><br><span class="line">                new String[]&#123;filePath&#125;, new String[]&#123;&quot;image/*&quot;&#125;,</span><br><span class="line">                new MediaScannerConnection.OnScanCompletedListener() &#123;</span><br><span class="line">                    public void onScanCompleted(String path, Uri uri) &#123;</span><br><span class="line">                        context.sendBroadcast(new Intent(android.hardware.Camera.ACTION_NEW_PICTURE, uri));</span><br><span class="line">                        context.sendBroadcast(new Intent(&quot;com.android.camera.NEW_PICTURE&quot;, uri));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        scanPhotos(filePath, context);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + filePath)));</span><br><span class="line">    &#125;</span><br><span class="line">    ToastUtils.showLongToast(context, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是进行截屏操作获取bitmap,然后将bitmap转化为文件，保存到sd卡自定义的目录，将保存后的文件相关信息插入到图库系统中，通知图库更新。在refreshPicture方法通知图库更新需要做版本判断，至于原因代码中注释都很清楚，就不多说了，两段代码合起来就是一个截图保存图片并且通知图库更新的实现了。（温馨提示，由于涉及文件操作，在targetSdkVersion为6.0以及以上需要进行权限的动态申请，权限不属于该篇的范畴就不介绍了）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>长截图一开始由于网上资料太少，钻了很多的牛角尖，花了很多的时间，后来转换了思路，利用传递View的方式，实现起来就简单多了，通用性也高，能够根据传递的View来进行截图。所以有时候遇到问题并且长时间得不到解决，应该静下来考虑换种思路去探寻，说不定就能找到好的解决方式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;主要讲述的是长截图的实现以及保存图片通知图库更新。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="//plstyle.cn/tags/Android/"/>
    
      <category term="长截图" scheme="//plstyle.cn/tags/%E9%95%BF%E6%88%AA%E5%9B%BE/"/>
    
      <category term="图库" scheme="//plstyle.cn/tags/%E5%9B%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CombineBitmap开源项目源码解析</title>
    <link href="//plstyle.cn/2018/07/06/blog_combine_bitmap/"/>
    <id>//plstyle.cn/2018/07/06/blog_combine_bitmap/</id>
    <published>2018-07-06T04:00:00.000Z</published>
    <updated>2018-07-06T12:51:13.054Z</updated>
    
    <content type="html"><![CDATA[<hr><p>近来在github上看到一个比较火的自定义View，仿微信以及钉钉群组头像生成，便好好学习了一番<br><a id="more"></a></p><h2 id="项目简述"><a href="#项目简述" class="headerlink" title="项目简述"></a>项目简述</h2><p>啥也不说，先看一波效果图：</p><p><img src="/img/pl/combine_bitmap_effect.png" alt=""></p><p>别看这只是一个小小的view，由于涉及Bitmap，所以对性能的处理也是必不可少，还得压缩组合bitmap展现出好的视觉效果；再者还得考虑网络加载还是Resource加载，以及缓存处理等，实现起来还是得费不少功夫的。</p><h3 id="结构简述"><a href="#结构简述" class="headerlink" title="结构简述"></a>结构简述</h3><p>项目结构如下：<br><img src="/img/pl/combine_bitmap_caterlog.png" alt=""><br>cache包下主要是内存缓存（LruCache）与磁盘缓存（DiskLruCache）的两个辅助类</p><p>handle包没啥东西，只是定了一个接口以及Handle的子类</p><p>layout包包含了根据特定的规则对bitmap进行组合的接口以及两个实现类DingLayoutManager(仿钉钉)以及WeChatLayoutManager(仿微信)</p><p>helper包包含的东西就比较杂，不过根据类名也比较好辨认，比如BitMapLoader(bitmap加载类)、Builder(builder的实体构造模式)、ThreadPool(线程池)还有一些CompressHelper(压缩)等</p><p>最外层的CombineBitmap一看就知道是入口类。<br>具体的调用方式如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">loadWechatBitmap</span>(ImageView imageView, int count) &#123;</span><br><span class="line">        <span class="selector-tag">CombineBitmap</span><span class="selector-class">.init</span>(MainActivity.this)</span><br><span class="line">                <span class="selector-class">.setLayoutManager</span>(new WechatLayoutManager())</span><br><span class="line">                <span class="selector-class">.setSize</span>(<span class="number">180</span>)</span><br><span class="line">                <span class="selector-class">.setGap</span>(<span class="number">3</span>)</span><br><span class="line">                <span class="selector-class">.setGapColor</span>(Color.parseColor(<span class="string">"#E8E8E8"</span>))</span><br><span class="line">                <span class="selector-class">.setUrls</span>(getUrls(count))</span><br><span class="line">                <span class="selector-class">.setImageView</span>(imageView)</span><br><span class="line">                <span class="selector-class">.build</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>从调用方式可知，通过builder的方式构造实体，根据实体中url属性是否为空来判断bitmap加载来源。如果url为空，则是从Resource加载，获取到bitmap后先进行采样率压缩然后根据特定的规则对bitmap数组进行组合并返回一个最终的bitmap，执行imageView.setBitmap（bitmap）就ok了。反之，采用的是三级缓存加载，加载规则是先从内存中加载，有则直接返回，没有就从磁盘加载，有则返回并且将其加入到内存缓存中，没有的话就从网络加载（HttpUrlConnecttion），加载完将其存入磁盘缓存中，并且从缓存中读取bitmap，这样就将其存入内存缓存了。获取到bitmap之后，操作就跟resource一样了，就是压缩组合了。当然其中还有运用到线程池、队列管理等。</p><h2 id="关键模块分析"><a href="#关键模块分析" class="headerlink" title="关键模块分析"></a>关键模块分析</h2><h3 id="Builder实体类构建："><a href="#Builder实体类构建：" class="headerlink" title="Builder实体类构建："></a>Builder实体类构建：</h3><p>如下图：<br><img src="/img/pl/combine_bitmap_builder.png" alt=""><br>builder实体相当于一个配置类，是与调用者直接关联的，这个类的设计是贯穿于整个项目结构的，通过这个配置类使用者就能了解这个框架或者开源库的大致功能以及使用，通过配置属性就能实现对应的功能。如上图，定义的属性都是项目设计过程中必不可少的并且让用户自定义的（都有注释我就不一一解释了）。</p><h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>主要是LruCache以及DiskLruCache，项目中LruCache采用的是v4包中，LruCacheHelper只是对其做了初始化配置以及get与add方法；磁盘缓存采用的是‘com.jakewharton:disklrucache’的依赖库，DiskCacheHelper只是对其进行初始化配置等。</p><h3 id="Bitmap组合模块"><a href="#Bitmap组合模块" class="headerlink" title="Bitmap组合模块"></a>Bitmap组合模块</h3><p>定义了一个接口以及两个实现类：<br>DingLayoutManager类：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * @param size  最终生成bitmap的尺寸</span></span><br><span class="line"><span class="comment">   * @param subSize  单个bitmap的尺寸</span></span><br><span class="line"><span class="comment">   * @param gap 每个小bitmap之间的距离</span></span><br><span class="line"><span class="comment">   * @param gapColor  间距的颜色</span></span><br><span class="line"><span class="comment">   * @param bitmaps  bitmap数组</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span> Bitmap combineBitmap(<span class="keyword">int</span> <span class="keyword">size</span>, <span class="keyword">int</span> subSize, <span class="keyword">int</span> gap, <span class="keyword">int</span> gapColor, Bitmap[] bitmaps) &#123;</span><br><span class="line">      Bitmap result = Bitmap.createBitmap(<span class="keyword">size</span>, <span class="keyword">size</span>, Bitmap.Config.ARGB_8888);</span><br><span class="line">      Canvas canvas = <span class="keyword">new</span> Canvas(result);</span><br><span class="line">      <span class="keyword">if</span> (gapColor == <span class="number">0</span>) &#123;</span><br><span class="line">          gapColor = Color.WHITE;</span><br><span class="line">      &#125;</span><br><span class="line">      canvas.drawColor(gapColor);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> <span class="keyword">count</span> = bitmaps.length;</span><br><span class="line">      Bitmap subBitmap;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[][] dxy = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (bitmaps[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          subBitmap = Bitmap.createScaledBitmap(bitmaps[i], <span class="keyword">size</span>, <span class="keyword">size</span>, <span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">count</span> == <span class="number">2</span> || (<span class="keyword">count</span> == <span class="number">3</span> &amp;&amp; i == <span class="number">0</span>)) &#123;</span><br><span class="line">              subBitmap = Bitmap.createBitmap(subBitmap, (<span class="keyword">size</span> + gap) <span class="regexp">/ 4, 0, (size - gap) /</span> <span class="number">2</span>, <span class="keyword">size</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">count</span> == <span class="number">3</span> &amp;&amp; (i == <span class="number">1</span> || i == <span class="number">2</span>)) || <span class="keyword">count</span> == <span class="number">4</span>) &#123;</span><br><span class="line">              subBitmap = Bitmap.createBitmap(subBitmap, (<span class="keyword">size</span> + gap) <span class="regexp">/ 4, (size + gap) /</span> <span class="number">4</span>, (<span class="keyword">size</span> - gap) <span class="regexp">/ 2, (size - gap) /</span> <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> dx = dxy[i][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">int</span> dy = dxy[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">          canvas.drawBitmap(subBitmap, dx * (<span class="keyword">size</span> + gap) <span class="regexp">/ 2.0f, dy * (size + gap) /</span> <span class="number">2.0</span>f, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>WeChatLayoutManager类:<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @param size  最终生成bitmap的尺寸</span></span><br><span class="line"><span class="comment">    * @param subSize  单个bitmap的尺寸</span></span><br><span class="line"><span class="comment">    * @param gap 每个小bitmap之间的距离</span></span><br><span class="line"><span class="comment">    * @param gapColor  间距的颜色</span></span><br><span class="line"><span class="comment">    * @param bitmaps  bitmap数组</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">public Bitmap combineBitmap(int size, int subSize, int gap, int gapColor, Bitmap[] bitmaps) &#123;</span><br><span class="line">       Bitmap <span class="attr">result</span> = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);</span><br><span class="line">       Canvas <span class="attr">canvas</span> = new Canvas(result);</span><br><span class="line">       <span class="keyword">if</span> (<span class="attr">gapColor</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="attr">gapColor</span> = Color.WHITE;</span><br><span class="line">       &#125;</span><br><span class="line">       canvas.drawColor(gapColor);</span><br><span class="line"></span><br><span class="line">       int <span class="attr">count</span> = bitmaps.length;</span><br><span class="line">       Bitmap subBitmap;</span><br><span class="line"></span><br><span class="line">       for (int <span class="attr">i</span> = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bitmaps[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="attr">subBitmap</span> = Bitmap.createScaledBitmap(bitmaps[i], subSize, subSize, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           float <span class="attr">x</span> = <span class="number">0</span>;</span><br><span class="line">           float <span class="attr">y</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">2</span>) &#123;</span><br><span class="line">               <span class="attr">x</span> = gap + i * (subSize + gap);</span><br><span class="line">               <span class="attr">y</span> = (size - subSize) / <span class="number">2.0</span>f;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">3</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = (size - subSize) / <span class="number">2.0</span>f;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">1</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = subSize + <span class="number">2</span> * gap;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">4</span>) &#123;</span><br><span class="line">               <span class="attr">x</span> = gap + (i % <span class="number">2</span>) * (subSize + gap);</span><br><span class="line">               <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">y</span> = subSize + <span class="number">2</span> * gap;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = <span class="attr">y</span> = (size - <span class="number">2</span> * subSize - gap) / <span class="number">2.0</span>f;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = (size + gap) / <span class="number">2.0</span>f;</span><br><span class="line">                   <span class="attr">y</span> = (size - <span class="number">2</span> * subSize - gap) / <span class="number">2.0</span>f;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">2</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = (size + gap) / <span class="number">2.0</span>f;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">6</span>) &#123;</span><br><span class="line">               <span class="attr">x</span> = gap + (i % <span class="number">3</span>) * (subSize + gap);</span><br><span class="line">               <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                   <span class="attr">y</span> = (size - <span class="number">2</span> * subSize - gap) / <span class="number">2.0</span>f;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">y</span> = (size + gap) / <span class="number">2.0</span>f;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">7</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = (size - subSize) / <span class="number">2.0</span>f;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">1</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = subSize + <span class="number">2</span> * gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">4</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = gap + <span class="number">2</span> * (subSize + gap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">8</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = (size - <span class="number">2</span> * subSize - gap) / <span class="number">2.0</span>f;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">i</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = (size + gap) / <span class="number">2.0</span>f;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">2</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = subSize + <span class="number">2</span> * gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">x</span> = gap + (i - <span class="number">5</span>) * (subSize + gap);</span><br><span class="line">                   <span class="attr">y</span> = gap + <span class="number">2</span> * (subSize + gap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">count</span> == <span class="number">9</span>) &#123;</span><br><span class="line">               <span class="attr">x</span> = gap + (i % <span class="number">3</span>) * (subSize + gap);</span><br><span class="line">               <span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                   <span class="attr">y</span> = gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                   <span class="attr">y</span> = subSize + <span class="number">2</span> * gap;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="attr">y</span> = gap + <span class="number">2</span> * (subSize + gap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           canvas.drawBitmap(subBitmap, x, y, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这是这个开源库最关键的部分，就是组合的规则，相信是作者花了不少时间研究的，具体的逻辑可以直接看代码，不是很难。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>压缩采用的是采样率压缩，可以先获取宽高，计算采样率，在进行采样率压缩，这样就可以减少内存消耗.<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bitmap compressDescriptor(FileDescriptor fd, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight) &#123;</span><br><span class="line">        BitmapFactory.<span class="keyword">Options</span> <span class="keyword">options</span> = <span class="keyword">new</span> BitmapFactory.<span class="keyword">Options</span>();</span><br><span class="line">        <span class="keyword">options</span>.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeFileDescriptor(fd, <span class="keyword">null</span>, <span class="keyword">options</span>);</span><br><span class="line">        <span class="keyword">options</span>.inSampleSize = calculateInSampleSize(<span class="keyword">options</span>, reqWidth, reqHeight);</span><br><span class="line">        <span class="keyword">options</span>.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeFileDescriptor(fd, <span class="keyword">null</span>, <span class="keyword">options</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="BitMapLoader"><a href="#BitMapLoader" class="headerlink" title="BitMapLoader"></a>BitMapLoader</h3><p>这是三级缓存加载类，采用的规则就是先从内存加载，再从磁盘最后是网络，是这个开源库中逻辑最复杂最缜密的地方，还采用了线程池以及自定义队列来管理任务。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class BitmapLoader &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> TAG = BitmapLoader.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> BUFFER_SIZE = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LruCacheHelper lruCacheHelper;</span><br><span class="line">    <span class="keyword">private</span> DiskLruCache mDiskLruCache;</span><br><span class="line">    <span class="keyword">private</span> CompressHelper compressHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> BitmapLoader manager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BitmapLoader getInstance(Context context) &#123;</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BitmapLoader.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    manager = <span class="keyword">new</span> BitmapLoader(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储线程池中的任务</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, Runnable&gt; doingTasks;</span><br><span class="line">    <span class="comment">// 存储暂时不能进入线程池的任务</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, List&lt;Runnable&gt;&gt; undoTasks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BitmapLoader(Context context) &#123;</span><br><span class="line">        mDiskLruCache = <span class="keyword">new</span> DiskLruCacheHelper(context).mDiskLruCache;</span><br><span class="line">        lruCacheHelper = <span class="keyword">new</span> LruCacheHelper();</span><br><span class="line">        compressHelper = CompressHelper.getInstance();</span><br><span class="line"></span><br><span class="line">        doingTasks = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        undoTasks = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> asyncLoad(<span class="keyword">final</span> <span class="built_in">int</span> index, <span class="keyword">final</span> <span class="keyword">String</span> url, <span class="keyword">final</span> <span class="built_in">int</span> reqWidth, <span class="keyword">final</span> <span class="built_in">int</span> reqHeight, <span class="keyword">final</span> Handler handler) &#123;</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                Bitmap bitmap = loadBitmap(url, reqWidth, reqHeight);</span><br><span class="line">                <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handler.obtainMessage(<span class="number">1</span>, index, <span class="number">-1</span>, bitmap).sendToTarget();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    handler.obtainMessage(<span class="number">2</span>, index, <span class="number">-1</span>, <span class="keyword">null</span>).sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (collectUndoTasks(url, task)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadPool.getInstance().getThreadPoolExecutor().execute(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap loadBitmap(<span class="keyword">String</span> url, <span class="built_in">int</span> reqWidth, <span class="built_in">int</span> reqHeight) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从内存缓存中读取</span></span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">key</span> = Utils.hashKeyFormUrl(url);</span><br><span class="line">        Bitmap bitmap = lruCacheHelper.getBitmapFromMemCache(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"load from memory:"</span> + url);</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试从磁盘缓存中读取</span></span><br><span class="line">            bitmap = loadBitmapFromDiskCache(url, reqWidth, reqHeight);</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"load from disk:"</span> + url);</span><br><span class="line">                <span class="keyword">return</span> bitmap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试下载</span></span><br><span class="line">            bitmap = loadBitmapFromHttp(url, reqWidth, reqHeight);</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"load from http:"</span> + url);</span><br><span class="line">                <span class="keyword">return</span> bitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap loadBitmapFromHttp(<span class="keyword">String</span> url, <span class="built_in">int</span> reqWidth, <span class="built_in">int</span> reqHeight)</span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">key</span> = Utils.hashKeyFormUrl(url);</span><br><span class="line">        <span class="comment">//判断当前mDiskLruCache是否已经在操作key，为null说明没有，不为null则直接返回</span></span><br><span class="line">        DiskLruCache.Editor editor = mDiskLruCache.edit(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (downloadUrlToStream(url, outputStream)) &#123;</span><br><span class="line">                editor.commit();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                editor.abort();</span><br><span class="line">            &#125;</span><br><span class="line">            mDiskLruCache.flush();</span><br><span class="line"></span><br><span class="line">            executeUndoTasks(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadBitmapFromDiskCache(url, reqWidth, reqHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">boolean</span> downloadUrlToStream(<span class="keyword">String</span> urlString,</span><br><span class="line">                                        OutputStream outputStream) &#123;</span><br><span class="line">        HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> URL url = <span class="keyword">new</span> URL(urlString);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream(), BUFFER_SIZE);</span><br><span class="line">            out = <span class="keyword">new</span> BufferedOutputStream(outputStream, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = in.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">                out.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"downloadBitmap failed."</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            Utils.close(out);</span><br><span class="line">            Utils.close(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap loadBitmapFromDiskCache(<span class="keyword">String</span> url, <span class="built_in">int</span> reqWidth,</span><br><span class="line">                                           <span class="built_in">int</span> reqHeight) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">key</span> = Utils.hashKeyFormUrl(url);</span><br><span class="line">        DiskLruCache.Snapshot snapShot = mDiskLruCache.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (snapShot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            FileInputStream fileInputStream = (FileInputStream) snapShot.getInputStream(<span class="number">0</span>);</span><br><span class="line">            FileDescriptor fileDescriptor = fileInputStream.getFD();</span><br><span class="line">            bitmap = compressHelper.compressDescriptor(fileDescriptor, reqWidth, reqHeight);</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lruCacheHelper.addBitmapToMemoryCache(<span class="built_in">key</span>, bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">boolean</span> collectUndoTasks(<span class="keyword">String</span> url, Runnable task) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">key</span> = Utils.hashKeyFormUrl(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lruCacheHelper.getBitmapFromMemCache(<span class="built_in">key</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiskLruCache.Snapshot snapShot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            snapShot = mDiskLruCache.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snapShot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前url下载操作过程的磁盘缓存的Editor未结束，又来了一个新的url，则不能正常生成新Editor</span></span><br><span class="line">        <span class="comment">// 则将新url对应的任务先保存起来</span></span><br><span class="line">        <span class="keyword">if</span> (doingTasks.containsKey(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (undoTasks.containsKey(<span class="built_in">key</span>))  &#123;</span><br><span class="line">                List&lt;Runnable&gt; tasks = undoTasks.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">                tasks.<span class="built_in">add</span>(task);</span><br><span class="line">                undoTasks.put(<span class="built_in">key</span>, tasks);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                tasks.<span class="built_in">add</span>(task);</span><br><span class="line">                undoTasks.put(<span class="built_in">key</span>, tasks);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doingTasks.put(<span class="built_in">key</span>, task);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> executeUndoTasks(<span class="keyword">String</span> url) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">key</span> = Utils.hashKeyFormUrl(url);</span><br><span class="line">        <span class="comment">// 检查undoTasks中是否有要执行的任务</span></span><br><span class="line">        <span class="keyword">if</span> (undoTasks.containsKey(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Runnable task : undoTasks.<span class="built_in">get</span>(<span class="built_in">key</span>)) &#123;</span><br><span class="line">                ThreadPool.getInstance().getThreadPoolExecutor().execute(task);</span><br><span class="line">            &#125;</span><br><span class="line">            undoTasks.remove(<span class="built_in">key</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从doingTasks中移除已经执行完的任务</span></span><br><span class="line">        doingTasks.remove(<span class="built_in">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>asyncLoad为入口方法，loadBimtap（）方法放入线程中执行，获取规则就是如上所述，先从内存再从磁盘再从网络，最后利用线程池去执行runnable。</p><p>这里重点说下两个map队列，分别是存储doingTask(正在执行的任务)以及undoTask(暂未执行的任务)。collectUndoTasks（）在执行runnable之前执行，如果从内存或者磁盘中根据key（url经过md5转化成特定位数的数）获取到对应的对象，直接返回false，即执行runnable;否则，判断doingTask是否包含对应的key,包含的话就将其存入undoTask，返回true不执行runnable，不包含就将其存入doingTask中，返回false去执行runnable。</p><p>在执行完网络加载操作loadBitmapFromHttp（key）方法，需要再次检测两个队列，undoTask如果包含key，就去执行对应的task,执行完从队列中移除掉key;还有就是把doingTask中的key给移除掉。</p><p>队列可以很好的管理各个对象的状态，方便各个地方获取使用，其add与remove操作得把握控制得当，随意的添加或者移除会产生事倍功半的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我个人对于此次CombineBitmap开源库的学习总结，这个库耦合性低，涉及的知识面也广，实现效果也不错，建议大家去fork学习使用。</p><p>CombineBitmap项目地址：<a href="https://github.com/Othershe/CombineBitmap" target="_blank" rel="noopener">https://github.com/Othershe/CombineBitmap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;近来在github上看到一个比较火的自定义View，仿微信以及钉钉群组头像生成，便好好学习了一番&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="//plstyle.cn/tags/Android/"/>
    
      <category term="Bitmap" scheme="//plstyle.cn/tags/Bitmap/"/>
    
      <category term="WeChat" scheme="//plstyle.cn/tags/WeChat/"/>
    
      <category term="DingDing" scheme="//plstyle.cn/tags/DingDing/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="//plstyle.cn/2018/07/04/blog_singleInstance/"/>
    <id>//plstyle.cn/2018/07/04/blog_singleInstance/</id>
    <published>2018-07-04T04:00:00.000Z</published>
    <updated>2018-07-04T10:14:02.162Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍单例模式以及常见几种单例模式以及它们的优缺点<br><a id="more"></a></p><h2 id="单例模式简述"><a href="#单例模式简述" class="headerlink" title="单例模式简述"></a>单例模式简述</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在项目开发中，为了节省不断创建对象而带来的资源开销，并且能够进行全局的访问，单例模式便应运而生。设计模式只是人们为了方便解决特定问题的而设计的框架或者结构，所以说设计模式不是万能的，它只是为了解决某类问题。</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>一个最简单的单例模式，是由两部分构成的，一个是私有的构造函数，另一个是公共的方法获取实例对象。如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(student == <span class="literal">null</span>)&#123;</span><br><span class="line">            student = <span class="keyword">new</span> Student();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="常见的几种单例模式"><a href="#常见的几种单例模式" class="headerlink" title="常见的几种单例模式"></a>常见的几种单例模式</h2><h3 id="静态内部类-推荐用-："><a href="#静态内部类-推荐用-：" class="headerlink" title="静态内部类[推荐用]："></a>静态内部类[推荐用]：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式跟<em>饿汉式方式</em>采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在<em>饿汉式</em>方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>优点：避免了线程不安全，延迟加载，效率高。</p><h3 id="双重检查-推荐用-："><a href="#双重检查-推荐用-：" class="headerlink" title="双重检查[推荐用]："></a>双重检查[推荐用]：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Double-Check</em>概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p><p>优点：线程安全；延迟加载；效率较高。</p><h3 id="饿汉式（静态常量-静态代码块）-可用-："><a href="#饿汉式（静态常量-静态代码块）-可用-：" class="headerlink" title="饿汉式（静态常量/静态代码块）[可用]："></a>饿汉式（静态常量/静态代码块）[可用]：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private final static Singleton<span class="built_in"> INSTANCE </span>= new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</p><h3 id="懒汉式-线程不安全-不可用"><a href="#懒汉式-线程不安全-不可用" class="headerlink" title="懒汉式(线程不安全)[不可用]"></a>懒汉式(线程不安全)[不可用]</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，<br>还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><h3 id="懒汉式-线程安全，同步方法-不推荐用"><a href="#懒汉式-线程安全，同步方法-不推荐用" class="headerlink" title="懒汉式(线程安全，同步方法)[不推荐用]"></a>懒汉式(线程安全，同步方法)[不推荐用]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决上面那种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。</p><p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><h3 id="懒汉式-线程安全，同步代码块-不可用"><a href="#懒汉式-线程安全，同步代码块-不可用" class="headerlink" title="懒汉式(线程安全，同步代码块)[不可用]"></a>懒汉式(线程安全，同步代码块)[不可用]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上一种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。<br>跟<em>懒汉式（线程不安全）</em>实现方式遇到的情形一致，假如一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。                           </p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍单例模式以及常见几种单例模式以及它们的优缺点&lt;br&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="//plstyle.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="单例" scheme="//plstyle.cn/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="java" scheme="//plstyle.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>对于获取设备标识的简述</title>
    <link href="//plstyle.cn/2018/06/29/blog_deviceId_GitHub/"/>
    <id>//plstyle.cn/2018/06/29/blog_deviceId_GitHub/</id>
    <published>2018-06-29T04:00:00.000Z</published>
    <updated>2018-06-29T13:07:50.110Z</updated>
    
    <content type="html"><![CDATA[<hr><p>介绍Android获取设备标识常见问题以及解决方案。<br><a id="more"></a></p><h2 id="常见的几种方式"><a href="#常见的几种方式" class="headerlink" title="常见的几种方式"></a>常见的几种方式</h2><h3 id="Imei"><a href="#Imei" class="headerlink" title="Imei"></a>Imei</h3><p>IMEI 国际移动设备身份码 目前GSM/WCDMA/LTE手机终端需要使用IMEI号码，在单卡工程中一个手机号对应一个IMEI号，双卡手机则会对应两个IMEI号，一张是手机卡对应一个。</p><h4 id="Imei获取"><a href="#Imei获取" class="headerlink" title="Imei获取"></a>Imei获取</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission <span class="keyword">android:name="android.permission.READ_PHONE_STATE"/&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">TelephonyManager </span>telephonyManager = (TelephonyManager)<span class="built_in">context</span>.getSystemService(<span class="built_in">context</span>.TELEPHONY_SERVICE)<span class="comment">;  </span></span><br><span class="line">String imei = telephonyManager.getDeviceId()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="Imei弊端"><a href="#Imei弊端" class="headerlink" title="Imei弊端"></a>Imei弊端</h4><p>由以上可以看出使用IMEI来作为Android的设备唯一标识符存在一定的弊端，如果用户禁用掉相关权限，那么对于以上获取参数的代码。则会直接报错，不会得到我们想要的内容。</p><h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>Mac 指的就是我们设备网卡的唯一设别码，该码全球唯一，一般称为物理地址，硬件地址用来定义设备的位置</p><h4 id="Mac地址获取"><a href="#Mac地址获取" class="headerlink" title="Mac地址获取"></a>Mac地址获取</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission <span class="keyword">android:name="android.permission.ACCESS_WIFI_STATE"/&gt; </span></span><br><span class="line">private void getMacAddress()&#123;</span><br><span class="line">    String macAddress = null<span class="comment">;</span></span><br><span class="line">    StringBuffer <span class="keyword">buf </span>= new StringBuffer()<span class="comment">;</span></span><br><span class="line">    NetworkInterface networkInterface = null<span class="comment">;</span></span><br><span class="line">    try &#123;</span><br><span class="line">        networkInterface = NetworkInterface.getByName(<span class="string">"eth1"</span>)<span class="comment">;</span></span><br><span class="line">        if (networkInterface == null) &#123;</span><br><span class="line">            networkInterface = NetworkInterface.getByName(<span class="string">"wlan0"</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (networkInterface == null) &#123;</span><br><span class="line">            return <span class="string">"02:00:00:00:00:02"</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte[] </span><span class="keyword">addr </span>= networkInterface.getHardwareAddress()<span class="comment">;</span></span><br><span class="line">        for (<span class="keyword">byte </span><span class="keyword">b </span>: <span class="keyword">addr) </span>&#123;</span><br><span class="line">            <span class="keyword">buf.append(String.format("%02X:", </span><span class="keyword">b));</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        if (<span class="keyword">buf.length() </span>&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">buf.deleteCharAt(buf.length() </span>- <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">            macAddress = <span class="keyword">buf.toString();</span></span><br><span class="line"><span class="keyword"> </span>       &#125; catch (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">            return <span class="string">"02:00:00:00:00:02"</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return macAddress<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mac地址弊端"><a href="#Mac地址弊端" class="headerlink" title="Mac地址弊端"></a>Mac地址弊端</h4><ul><li><p>如果使用Mac地址最重要的一点就是手机必须具有上网功能</p></li><li><p>在Android6.0以后google为了运行时权限对geMacAddress();作出修改通过该方法得到的mac地址永远是一样的， 但是可以其他途径获取。</p></li></ul><h3 id="Android-Id"><a href="#Android-Id" class="headerlink" title="Android Id"></a>Android Id</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> ANDROID_ID = Settings.<span class="keyword">System</span>.getString(getContentResolver(), Settings.<span class="keyword">System</span>.ANDROID_ID);</span><br></pre></td></tr></table></figure><h4 id="Android-ID弊端"><a href="#Android-ID弊端" class="headerlink" title="Android ID弊端"></a>Android ID弊端</h4><ul><li><p>手机恢复出厂设置以后该值会发生变化</p></li><li><p>在国内Android定制的大环境下，有些设备是不会返回ANDROID_ID的</p></li></ul><h3 id="Serial-Number（设备序列号）"><a href="#Serial-Number（设备序列号）" class="headerlink" title="Serial Number（设备序列号）"></a>Serial Number（设备序列号）</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">String SerialNumber</span> = android.os.Build.SERIAL;</span><br></pre></td></tr></table></figure><h4 id="Serial-Number弊端"><a href="#Serial-Number弊端" class="headerlink" title="Serial Number弊端"></a>Serial Number弊端</h4><p>获取序列号不需要权限，但是有一定的局限性，在有些手机上会出现垃圾数据，比如红米手机返回的就是连续的非随机数</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>比较以上几种方法。如果只是考虑单独使用，那么在不同程度上在用户使用的情况下都会出现无法生成或者生成无效设备唯一标识符的情况。所以我在开发中采用混合使用的方式，同时结合SD卡以及sharepreference进行本地持久化处理。</p><h3 id="设计简述"><a href="#设计简述" class="headerlink" title="设计简述"></a>设计简述</h3><p>在开发中通过结合 device_id 、 MacAddress 以及 随机生成的 UUID 进行生成设备唯一标识符。 然后通过把生成的唯一标识符写到SD卡中一个隐藏目录中（为什么是写到影藏文件中呢，主要是避免用户看见然后手动删除）。同时会在相应App sharepreference 进行保存一份。</p><p>用户首先获取deviceId，获取到的话就直接返回，获取不到的话就从sharepreference中获取，获取到就返回，获取不到就从File中获取，获取到就返回并且保存到SharePreference中，获取不到就主动构建并且保存到隐藏文件与SharePreference中，方便下次调用</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TelephonyManager <span class="keyword">tm</span> = (TelephonyManager) mActivity</span><br><span class="line">        .getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">String myIMEI = <span class="keyword">tm</span>.getDeviceId();</span><br><span class="line">// 对IMEI号进行加密</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(myIMEI)) &#123;</span><br><span class="line">   //先从sp中获取，获取不到的话再从<span class="keyword">file</span>中获取，获取到的话进行sp存储；<span class="keyword">file</span>获取不到的话重新生成,并且做保存操作</span><br><span class="line">   myIMEI=DeviceIdUtils.getDeviceId(mActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeviceIdUtils类如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DeviceIdUtils &#123;</span><br><span class="line">    <span class="comment">//保存文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> CACHE_IMAGE_DIR = <span class="string">"aray/cache/devices"</span>;</span><br><span class="line">    <span class="comment">//保存的文件 采用隐藏文件的形式进行保存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> DEVICES_FILE_NAME = <span class="string">".DEVICES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取设备唯一标识符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getDeviceId(Context context) &#123;</span><br><span class="line">        <span class="keyword">String</span> deviceId = SpUtils.getString(context, SpConstant.SP_DEVICES_ID, <span class="string">""</span>);</span><br><span class="line">        <span class="built_in">if</span> (!StringUtils.isEmpty(deviceId)) &#123;</span><br><span class="line">            <span class="comment">//生成deviceId并且保存到file以及sp</span></span><br><span class="line">            <span class="built_in">return</span> deviceId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取保存的在sd卡中的唯一标识符</span></span><br><span class="line">        deviceId = readDeviceID(context);</span><br><span class="line">        <span class="comment">//判断是否已经生成过,</span></span><br><span class="line">        <span class="built_in">if</span> (!StringUtils.isEmpty(deviceId)) &#123;</span><br><span class="line">            <span class="comment">//保存到sp中</span></span><br><span class="line">            SpUtils.putString(context, SpConstant.SP_DEVICES_ID, deviceId);</span><br><span class="line">            <span class="built_in">return</span> deviceId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于生成最终的唯一标识符</span></span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取设备的MACAddress地址 去掉中间相隔的冒号</span></span><br><span class="line">            deviceId = getLocalMac(context);</span><br><span class="line">            <span class="built_in">if</span>(!StringUtils.isEmpty(deviceId))&#123;</span><br><span class="line">                deviceId = deviceId.replace(<span class="string">":"</span>, <span class="string">""</span>);</span><br><span class="line">                s.append(deviceId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//UUID生成随机字符串</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        deviceId = uuid.toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        s.append(deviceId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了统一格式对设备的唯一标识进行md5加密 最终生成32位字符串</span></span><br><span class="line">        <span class="keyword">String</span> md5 = getMD5(s.toString(), false);</span><br><span class="line">        <span class="built_in">if</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//持久化操作, 进行保存到SD卡中</span></span><br><span class="line">            saveDeviceID(md5, context);</span><br><span class="line">            <span class="comment">//保存到sp中</span></span><br><span class="line">            SpUtils.putString(context, SpConstant.SP_DEVICES_ID, md5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取固定的文件中的内容,这里就是读取sd卡中保存的设备唯一标识符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> readDeviceID(Context context) &#123;</span><br><span class="line">        <span class="built_in">File</span> file = getDevicesDir(context);</span><br><span class="line">        StringBuffer <span class="built_in">buffer</span> = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">            Reader in = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="built_in">while</span> ((i = in.<span class="built_in">read</span>()) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">buffer</span>.append((<span class="keyword">char</span>) i);</span><br><span class="line">            &#125;</span><br><span class="line">            in.<span class="built_in">close</span>();</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">buffer</span>.toString();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取设备MAC 地址 由于 6.0 以后 WifiManager 得到的 MacAddress得到都是 相同的没有意义的内容</span></span><br><span class="line"><span class="comment">     * 所以采用以下方法获取Mac地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> getLocalMac(Context context) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">macAddress</span> = null;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        NetworkInterface networkInterface = null;</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            networkInterface = NetworkInterface.getByName(<span class="string">"eth1"</span>);</span><br><span class="line">            <span class="built_in">if</span> (networkInterface == null) &#123;</span><br><span class="line">                networkInterface = NetworkInterface.getByName(<span class="string">"wlan0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span> (networkInterface == null) &#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] addr = networkInterface.getHardwareAddress();</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">byte</span> b : addr) &#123;</span><br><span class="line">                buf.append(<span class="keyword">String</span>.format(<span class="string">"%02X:"</span>, b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.deleteCharAt(buf.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">macAddress</span> = buf.toString();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">macAddress</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存 内容到 SD卡中,  这里保存的就是 设备唯一标识符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param str</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> saveDeviceID(<span class="keyword">String</span> str, Context context) &#123;</span><br><span class="line">        <span class="built_in">File</span> file = getDevicesDir(context);</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            Writer out = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"UTF-8"</span>);</span><br><span class="line">            out.<span class="built_in">write</span>(str);</span><br><span class="line">            out.<span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对挺特定的 内容进行 md5 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param message   加密明文</span></span><br><span class="line"><span class="comment">     * @param upperCase 加密以后的字符串是是大写还是小写  true 大写  false 小写</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getMD5(<span class="keyword">String</span> message, <span class="keyword">boolean</span> upperCase) &#123;</span><br><span class="line">        <span class="keyword">String</span> md5str = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] input = message.getBytes();</span><br><span class="line">            <span class="keyword">byte</span>[] buff = md.digest(input);</span><br><span class="line">            md5str = bytesToHex(buff, upperCase);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> md5str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> bytesToHex(<span class="keyword">byte</span>[] bytes, <span class="keyword">boolean</span> upperCase) &#123;</span><br><span class="line">        StringBuffer md5str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> digital;</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            digital = bytes[i];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">if</span> (digital &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                digital += <span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span> (digital &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                md5str.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            md5str.append(Integer.toHexString(digital));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (upperCase) &#123;</span><br><span class="line">            <span class="built_in">return</span> md5str.toString().toUpperCase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> md5str.toString().toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一处理设备唯一标识 保存的文件的地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param context</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">File</span> getDevicesDir(Context context) &#123;</span><br><span class="line">        <span class="built_in">File</span> mCropFile = null;</span><br><span class="line">        <span class="built_in">if</span> (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">            <span class="built_in">File</span> cropdir = <span class="keyword">new</span> <span class="built_in">File</span>(Environment.getExternalStorageDirectory(), CACHE_IMAGE_DIR);</span><br><span class="line">            <span class="built_in">if</span> (!cropdir.<span class="built_in">exists</span>()) &#123;</span><br><span class="line">                cropdir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            mCropFile = <span class="keyword">new</span> <span class="built_in">File</span>(cropdir, DEVICES_FILE_NAME); <span class="comment">// 用当前时间给取得的图片命名</span></span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="built_in">File</span> cropdir = <span class="keyword">new</span> <span class="built_in">File</span>(context.getFilesDir(), CACHE_IMAGE_DIR);</span><br><span class="line">            <span class="built_in">if</span> (!cropdir.<span class="built_in">exists</span>()) &#123;</span><br><span class="line">                cropdir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            mCropFile = <span class="keyword">new</span> <span class="built_in">File</span>(cropdir, DEVICES_FILE_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> mCropFile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设备标识获取的思路大致就是结合deviceId、SharePreference以及隐藏文件，优先级从高到低，具体使用可以结合实际场景做适当的修正。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;介绍Android获取设备标识常见问题以及解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="deviceId" scheme="//plstyle.cn/tags/deviceId/"/>
    
      <category term="SharePreference" scheme="//plstyle.cn/tags/SharePreference/"/>
    
      <category term="File" scheme="//plstyle.cn/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Android的IPC机制</title>
    <link href="//plstyle.cn/2018/06/13/blog_ipc_GitHub/"/>
    <id>//plstyle.cn/2018/06/13/blog_ipc_GitHub/</id>
    <published>2018-06-13T04:00:00.000Z</published>
    <updated>2018-06-13T06:23:17.653Z</updated>
    
    <content type="html"><![CDATA[<hr><p>简要介绍Android IPC和多进程的运行模式以及常见的几种IPC方式。<br><a id="more"></a></p><h2 id="IPC简介"><a href="#IPC简介" class="headerlink" title="IPC简介"></a>IPC简介</h2><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程间进行数据交换的过程。</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程一般指一个执行单元，在PC或者移动设备上指一个程序或者一个应用；线程是CPU调度的最小单元，同时线程也是一种有限的系统资源。一个进程可以包含多个线程，两者是包含的关系。例如在Android应用中，默认都含有一个主线程，也叫做UI线程，用于操作一些界面绘制的任务，如果把一些耗时任务放在UI线程中，就会引起ANR(应用没有响应)，所以必须将其放入到子线程中进行。</p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>对于Android开发者来说，Binder应该是既熟悉又陌生，熟悉是因为在Android系统中它无处不在，陌生是因为它学习门槛高，从应用开发层贯穿至linux内核层，要深入了解你必须苦下功夫，阅读源码。所以binder很复杂，这边简要介绍binder使用以及上层原理。</p><p>Binder是Android的一个实现了Ibinder接口的类，它是一种跨进程的通信方式。在Linux内核层，它是一种虚拟的物理设备，它含有自己设备驱动在Linux内核层负责与硬件进行交互；在应用层与FrameWork层，Binder充当的是客户端与服务端进行消息交换的媒介，相当于一个中间层，对消息进行包装（封装成Binder对象），客户端就可以通过该对象来获取服务端的内容（客户端与服务端是可以随时互换的，并不是固定不变的）。</p><h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><h3 id="多进程设置"><a href="#多进程设置" class="headerlink" title="多进程设置"></a>多进程设置</h3><p>多进程的配置很简单，只要在Manifests配置文件中，给四大组件配上android:process属性即可，配置完运行即可在AndroidStudio或者Adb命令查看到多个进程以及相应的ID。</p><h3 id="多进程运行机制"><a href="#多进程运行机制" class="headerlink" title="多进程运行机制"></a>多进程运行机制</h3><p>Android会为每个进程分配一个虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致不同的虚拟机访问同一个类会产生多个副本。例如：进程A与进程B，类C含有一个静态属性，在进程A中将其值改变，而在进程B中读取的还是之前未改变的值，这就产生了一个同步的差异。</p><p>多进程一般会产生一下几个问题：</p><p>1、静态成员与单例完全失效</p><p>2、线程同步机制完全失效</p><p>3、SharePreference可靠性下降</p><p>4、Apllication会创建多次</p><p>第1与第2个问题都是因为内存地址不同造成的；第3个问题是由于多进程并发读写Xml文件，可能造成数据丢失或者错乱；第四个问题是Android系统机制决定的，每个进程都会分配一个独立的虚拟机，这个过程其实就是启动一个应用的过程</p><h2 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h2><p>由上可知，在多进程中不能像单进程一样操作，否则会造成很多潜在的问题，必须用进程间通信来处理跨域问题，以下是常见几种IPC方式</p><h3 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h3><p>通过Intent传递Bundle数据可用于实现组件（Activity、Service以及Receiver）之间消息通信，Bundle实现了Parceable接口，方便在不同进程间通信。Bundle支持的类型有基本类型、Parceable以及Serializable以及Android支持的特殊对象。例如：进程A的<br>aActivity直接用Intent(消息封装成Bundle对象)传递给进程B的bActivity,bActivity就能获取bundle中消息，实现进程间的通信了。</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>文件共享顾名思义就是利用文件来存储数据，然后通过对文件的读写来实现数据共享。由上可知，多进程时可能会造成高并发操作文件，导致数据错乱或者不可靠，所以文件共享适合对数据同步要求不高的进程之间通信，并且要妥善处理并发读写问题。</p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDL是应用接口定义语言，是用于实现进程间通信的，主要分为客户端与服务端。</p><p>服务端：</p><p>服务端首先要创建一个Service用来监听客户端的请求，然后创建一个AIDL文件，将暴露给客户端的接口在AIDL文件中声明，最后在Service中实现这个AIDL接口即可。</p><p>客户端：</p><p>客户端要做的事稍微简单点，首先需要绑定服务端的Service,绑定成功后，将服务端返回的Binder对象转换成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</p><p>对于AIDL文件的创建以及具体的代码事例这里就不进行介绍了，想了解的同学可以上网查找。</p><h3 id="Messeneger"><a href="#Messeneger" class="headerlink" title="Messeneger"></a>Messeneger</h3><p>Messenger可以翻译为信使，通过它可以在不同进程间传递Message对象，将数据封装成Message，就可以轻松实现进程间传递了。Messenger是一种轻量级的IPC方案，它的底层实现是aidl,它是串行执行请求的，不能并发处理多个客户端的请求，所以它只适用于一些非高并发请求的场景。如下是它的实现流程图：</p><p><img src="/img/pl/ipc_messenger.png" alt=""></p><h3 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h3><p>ContentProvider是内容提供者，对于Android开发者来说这个应该不陌生，它是四大组件之一，它的搭档是ContentResolver(内容解析者)。底层是基于binder实现的，Android系统帮我们做好了封装，我们可以很简单的就能实现IPC。实现一个ContentProvider需要继承ContentProvider类，并且重写CRUD四个方法，并对其进行注册设置标识，其它应用或者进程通过ContentResolver与标识对其进行解析，这就实现了进程间的通信了。当然ContentProvider存储的媒介是多样的，可以是数据库、文件或者其它。</p><h3 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h3><p>Socket也成为“套接字”，是网络通信中的概念，分为流式套接字以及用户数据报套接字两种，分别对应Tcp(可靠传输)与Udp(不可靠传输)协议。socket是基于客户端/服务器模式的，服务端启动一个服务监听客户端的连接，当有客户端接进来时，就可以进行消息传递了。客户端就是配置好ip以及端口号，发送连接请求给服务端即可。当然对于服务端的设计还是有点讲究的，需要考虑到多客户端接入处理效率以及资源的回收等问题，这里就不多做描述了，有兴趣的同学可以自己尝试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍的IPC方式多种多样，对于开发者来说选择合适的IPC方式是相当重要的，如下图：</p><p><img src="/img/pl/ipc_difference.png" alt=""></p><p>当然Android的IPC岂是一篇博客能够讲完的，这里只是对其作了大致的介绍，对于binder、aidl以及Messenger等都没有做深入研究，有兴趣的同学可以阅读对应的源码进行研究探索。</p><p>参考书籍：《Android开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;简要介绍Android IPC和多进程的运行模式以及常见的几种IPC方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="IPC" scheme="//plstyle.cn/tags/IPC/"/>
    
      <category term="Binder" scheme="//plstyle.cn/tags/Binder/"/>
    
      <category term="AIDL" scheme="//plstyle.cn/tags/AIDL/"/>
    
      <category term="Messenger" scheme="//plstyle.cn/tags/Messenger/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Serializable与Parcelable</title>
    <link href="//plstyle.cn/2018/06/06/blog_serialization_GitHub/"/>
    <id>//plstyle.cn/2018/06/06/blog_serialization_GitHub/</id>
    <published>2018-06-06T04:00:00.000Z</published>
    <updated>2018-06-08T15:06:35.850Z</updated>
    
    <content type="html"><![CDATA[<hr><p>简要介绍序列化以及反序列化，以及两种实现方式Serializable和Parcelable还有二者的区别<br><a id="more"></a></p><h2 id="序列化与反序列化的由来"><a href="#序列化与反序列化的由来" class="headerlink" title="序列化与反序列化的由来"></a>序列化与反序列化的由来</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。即对象转换为字节序列。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>顾名思义，就是从存储区上反序列化对象的状态，重新<em>创建</em>对象。即字节序列重新转换为对象。</p><h3 id="两者的由来"><a href="#两者的由来" class="headerlink" title="两者的由来"></a>两者的由来</h3><p>在日常java编程中，网络传输以及文件存储等操作是必不可少的。序列化能保证网络传输以及文件存储中对象的一致性与持久性，不会发生错乱；反序列化能重新创建一个相同的对象，所以说序列化与反序列化也是java编程中必不可少的。</p><h2 id="如何实现序列化"><a href="#如何实现序列化" class="headerlink" title="如何实现序列化"></a>如何实现序列化</h2><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p><em>Serializable</em>是java提供的一个序列化的接口，它是一个空接口，为对象提供标准的序列化与反序列化操作。实体定义如下<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyPig</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final long serialVersionUID = <span class="number">1</span>L;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> AGE = <span class="string">"269"</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> color;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>Serializable</em>来实现序列化非常简单，只需要实现该接口并且定义一个<em>serialVersionUID</em>就行，其余的工作都交给系统自动化进行了。如何进行对象的序列化与反序列化也非常简单，只需要<em>ObjectOutputStream</em>与<em>ObjectInputStream</em>即可轻松实现，如下<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">  FlyPig flyPig = <span class="keyword">new</span> <span class="type">FlyPig</span>(<span class="string">"black"</span>,<span class="string">"naruto"</span>,<span class="string">"0000"</span>);  </span><br><span class="line">  ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"d:/flyPig.txt"</span>)));  </span><br><span class="line">  oos.writeObject(flyPig);  </span><br><span class="line">  oos.close();  </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">  ObjectInputStream ois = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"d:/flyPig.txt"</span>)));  </span><br><span class="line">        FlyPig person = (FlyPig) ois.readObject();</span><br></pre></td></tr></table></figure></p><p>上面提到要指定<em>serialVersionUID</em>（通常制定为1L即可，系统会自动生成hash值），不指定能否进行序列化呢？答案是yes。<em>serialVersionUID</em>只是一个标识，用来辅助序列化与反序列化过程的，原则上序列化后的<em>serialVersionUID</em>只有和当前类的<em>serialVersionUID</em>相同才能被反序列化。原理就是序列化是将该字段写入文件或者其它中介，在反序列时先比对该字段，相同则可以反序列化成功，不同则抛异常<em>InvalidClassException</em>。</p><p>不指定<em>serialVersionUID</em>，当类新增或者删除属性时，系统会重新计算该类的hash并赋给<em>serialVersionUID</em>，这时候就会不一致导致反序列化失败，程序出现crash。手动指定就可以避免这种情况。当然如果类结构改变的话，尽管<em>serialVersionUID</em>验证通过，还是会序列化失败，因为类结构发生改变，无法从老版本的数据中还原出一个新的类结构对象</p><h3 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h3><p><em>Parcelable</em>是Android新提供的序列化方式，相对于<em>Serializable</em>，它的实现稍微复杂一点。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelableType</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    String name;  </span><br><span class="line">    <span class="keyword">boolean</span> isGood;  </span><br><span class="line">    <span class="keyword">boolean</span> complete;  </span><br><span class="line">    <span class="keyword">private</span> String[] ids;  </span><br><span class="line">    <span class="keyword">private</span> OrderInfoBean bean;  </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;OrderInfoBean&gt; listBeans;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 默认构造方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> ParcelableType() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> ParcelableType(Parcel <span class="keyword">in</span>) &#123;  </span><br><span class="line">        readFromParcel(<span class="keyword">in</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*** </span></span><br><span class="line"><span class="comment">     * 默认实现 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> describeContents() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> writeToParcel(Parcel dest, <span class="keyword">int</span> flags) &#123;  </span><br><span class="line">        dest.writeInt(age);  </span><br><span class="line">        dest.writeString(name);  </span><br><span class="line">        dest.writeInt(isGood ? 1 : <span class="number">0</span>);  </span><br><span class="line">        dest.writeInt(complete ? 1 : <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ids != <span class="literal">null</span>) &#123;  </span><br><span class="line">            dest.writeInt(ids.length);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            dest.writeInt(<span class="number">0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        dest.writeStringArray(ids);  </span><br><span class="line">        dest.writeParcelable(bean, flags);  </span><br><span class="line">        dest.writeList(listBeans);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> readFromParcel(Parcel <span class="keyword">in</span>) &#123;  </span><br><span class="line">        age = <span class="keyword">in</span>.readInt();  </span><br><span class="line">        name = <span class="keyword">in</span>.readString();  </span><br><span class="line">        isGood = (<span class="keyword">in</span>.readInt() == <span class="number">1</span>) ? true : <span class="literal">false</span>;  </span><br><span class="line">        complete = (<span class="keyword">in</span>.readInt() == <span class="number">1</span>) ? true : <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">in</span>.readInt();  </span><br><span class="line">        ids = <span class="keyword">new</span> String[length];  </span><br><span class="line">        <span class="keyword">in</span>.readStringArray(ids);  </span><br><span class="line">        bean = <span class="keyword">in</span>.readParcelable(OrderInfoBean.<span class="keyword">class</span>.getClassLoader());  </span><br><span class="line">        listBeans = <span class="keyword">in</span>.readArrayList(OrderInfoBean.<span class="keyword">class</span>.getClassLoader());  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;ParcelableType&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;ParcelableType&gt;() &#123;  </span><br><span class="line">        <span class="keyword">public</span> ParcelableType createFromParcel(Parcel <span class="keyword">in</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ParcelableType(<span class="keyword">in</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> ParcelableType[] newArray(<span class="keyword">int</span> size) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ParcelableType[size];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>Parcel</em>内部包装了可序列化的数据，可在Binder中自由的传递。从以上代码可以看出，序列化过程包含序列化、反序列化以及功能描述。序列化由<em>writeToParcel</em>方法完成，最终通过Parcel的一系列write方法完成；反序列化通过<em>CREATOR</em>来完成，其内部标识了如何创建序列化对象以及数组，并通过Parcel的一系列read方法来完成反序列化的过程；内容描述功能由<em>describeContents</em>方法完成，几乎所有的情况这个方法都返回0，只有当前对象存在文件描述符时，此方法返回1。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Android开发来说，<em>Parcelable</em>与<em>Serializable</em>都能实现序列化并且都可用于Intent之间的数据传递，那么二者该如何选取呢？<em>Serializable</em>是java的序列化接口，其使用起来简单但是开销很大，序列化与反序列化过程需大量的IO操作。而<em>Parcelable</em>是Android的序列化方式，因此更适用于Android平台，它的缺点就是使用起来麻烦一点，但是效率更高，是Android推荐的序列化方法，我们应该首选<em>Parcelable</em>。<em>Parcelable</em>主要用在内存序列化上，通过<em>Parcelable</em>将对象序列化到存储设备或者将对象序列化后通过网络传输也都是可以的，但是这个过程会稍显复杂，因此在这两种情况建议大家使用<em>Serializable</em>。</p><p>参考书籍：《Android开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;简要介绍序列化以及反序列化，以及两种实现方式Serializable和Parcelable还有二者的区别&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="Serializable" scheme="//plstyle.cn/tags/Serializable/"/>
    
      <category term="Parcelable" scheme="//plstyle.cn/tags/Parcelable/"/>
    
  </entry>
  
  <entry>
    <title>基于Rxjava+okhttp+retrofit的网络框架搭建</title>
    <link href="//plstyle.cn/2018/04/25/blog_restful_GitHub/"/>
    <id>//plstyle.cn/2018/04/25/blog_restful_GitHub/</id>
    <published>2018-04-25T08:00:00.000Z</published>
    <updated>2018-06-13T06:50:40.086Z</updated>
    
    <content type="html"><![CDATA[<hr><p>基于Rxjava+okhttp+retrofit搭建的网络请求框架，封装了练手项目中的各个表对应的基本网络请求<br><a id="more"></a></p><h2 id="开发背景"><a href="#开发背景" class="headerlink" title="开发背景"></a>开发背景</h2><p>本框架是基于Rxjava2+retrofit2+okhttp3，可以实现线程之间的快速切换；处理数据简洁易懂，易于进行元素间的变换；可以简单处理大量的嵌套异步回调等。但是使用Retrofit+RxJava+OkHttp完成一次网络请求还是需要写很多代码的，所以肯定是需要再次封装的。该框架的目标是使开发者不用花费精力是理解网络请求的内部实现以及uri等配置，只需要调用对应的业务方法即可完成网络请求，当然更高目标是架构清晰，易于扩展，耦合度低。</p><h2 id="框架搭建以及介绍"><a href="#框架搭建以及介绍" class="headerlink" title="框架搭建以及介绍"></a>框架搭建以及介绍</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>   app gradle配置：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">implementation</span> <span class="string">"com.squareup.retrofit2:retrofit:<span class="variable">$rootProject</span>.retrofitVersion"</span></span><br><span class="line">    implementation <span class="string">"com.squareup.retrofit2:converter-gson:<span class="variable">$rootProject</span>.retrofitVersion"</span></span><br><span class="line">    implementation <span class="string">"com.jakewharton.retrofit:retrofit2-rxjava2-adapter:<span class="variable">$rootProject</span>.rxjavaAdapter"</span></span><br><span class="line">    implementation <span class="string">"com.squareup.okhttp3:logging-interceptor:<span class="variable">$rootProject</span>.okhttploggingVersion"</span></span><br><span class="line">    implementation <span class="string">"com.squareup.okhttp3:okhttp:<span class="variable">$rootProject</span>.okhttpVersion"</span></span><br><span class="line">    implementation <span class="string">"io.reactivex.rxjava2:rxjava:<span class="variable">$rootProject</span>.rxjavaVersion"</span></span><br><span class="line">    implementation <span class="string">"io.reactivex.rxjava2:rxandroid:<span class="variable">$rootProject</span>.rxandroidVersion"</span></span><br><span class="line">implementation <span class="string">"com.jakewharton.rxbinding2:rxbinding:<span class="variable">$rootProject</span>.rxbindingVersion"</span></span><br></pre></td></tr></table></figure></p><p>Project gradle配置<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    retrofitVersion = '<span class="number">2.2</span><span class="number">.0</span>'</span><br><span class="line">    okhttploggingVersion = '<span class="number">3.4</span><span class="number">.1</span>'</span><br><span class="line">    okhttpVersion = '<span class="number">3.4</span><span class="number">.1</span>'</span><br><span class="line">    rxjavaVersion = '<span class="number">2.1</span><span class="number">.0</span>'</span><br><span class="line">    rxandroidVersion = '<span class="number">2.0</span><span class="number">.1</span>'</span><br><span class="line">    rxbindingVersion = '<span class="number">2.0</span><span class="number">.0</span>'</span><br><span class="line">    rxjavaAdapter = '<span class="number">1.0</span><span class="number">.0</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、架构展示"><a href="#2、架构展示" class="headerlink" title="2、架构展示"></a>2、架构展示</h3><p><img src="/img/pl/project_structure.png" alt=""></p><h3 id="3、关键模块解析"><a href="#3、关键模块解析" class="headerlink" title="3、关键模块解析"></a>3、关键模块解析</h3><p><strong>RxHelper</strong>：是一个Rxjava的辅助类，主要提供线程切换等方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ObservableTransformer&lt;T, T&gt; <span class="title">rxSchedulerHelper</span><span class="params">()</span> </span>&#123;<span class="comment">//compose处理线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObservableTransformer&lt;T, T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;T&gt; <span class="title">apply</span><span class="params">(Observable&lt;T&gt; upstream)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                        .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>RetrofitCreateHelper</strong>：是框架的核心类，包含okhttp以及retrofit配置以及Api接口的反射调用等。采用gson实现json字符串与实体类之间的自动转化<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT_READ = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT_CONNECTION = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HttpLoggingInterceptor interceptor = <span class="keyword">new</span> HttpLoggingInterceptor()</span><br><span class="line">            .setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CacheInterceptor cacheInterceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HeaderInterceptor headerInterceptor = <span class="keyword">new</span> HeaderInterceptor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            <span class="comment">//SSL证书</span></span><br><span class="line">            .sslSocketFactory(TrustManager.getUnsafeOkHttpClient())</span><br><span class="line">            .hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)</span><br><span class="line">            .addInterceptor(headerInterceptor)</span><br><span class="line">            .addInterceptor(interceptor)   <span class="comment">//打印日志</span></span><br><span class="line">            .addNetworkInterceptor(cacheInterceptor)  <span class="comment">//设置Cache拦截器</span></span><br><span class="line">            .addInterceptor(cacheInterceptor)</span><br><span class="line">            .cache(HttpCache.getCache())</span><br><span class="line">            <span class="comment">//time out</span></span><br><span class="line">            .connectTimeout(TIMEOUT_CONNECTION, TimeUnit.SECONDS)</span><br><span class="line">            .readTimeout(TIMEOUT_READ, TimeUnit.SECONDS)</span><br><span class="line">            .writeTimeout(TIMEOUT_READ, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//失败重连</span></span><br><span class="line">            .retryOnConnectionFailure(<span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createApi</span><span class="params">(Class&lt;T&gt; clazz, String url)</span> </span>&#123;</span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(url)</span><br><span class="line">                .client(okHttpClient)</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> retrofit.<span class="title">create</span><span class="params">(clazz)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>RxManager</strong>：提供Rxjava中订阅者的注册订阅与取消订阅<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RxManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeDisposable mCompositeDisposable = <span class="keyword">new</span> CompositeDisposable();<span class="comment">// 管理订阅者者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span>(<span class="params">Disposable d</span>) </span>&#123;</span><br><span class="line">        mCompositeDisposable.<span class="keyword">add</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unSubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        mCompositeDisposable.dispose();<span class="comment">// 取消订阅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Okhttp包</strong>：主要就是定义一些okhttp的拦截器，包含缓存拦截器和https认证等，其中由于采用的是bomb的后台，需要添加一个header拦截器，自定义一些header。okhttp采用的是责任链拦截器的模式，采用的是类似U型的调用，后一个拦截器执行失败则结束，成功则将结果返回给前一个拦截器，以此类推，直至首个拦截器，则完成一次完整的网络请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLSocketFactory <span class="title">getUnsafeOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Create a trust manager that does not validate certificate chains</span></span><br><span class="line">            <span class="keyword">final</span> X509TrustManager[] trustAllCerts = <span class="keyword">new</span> X509TrustManager[]&#123;<span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        X509Certificate[] chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Install the all-trusting trust manager</span></span><br><span class="line">            <span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">            sslContext.init(<span class="keyword">null</span>, trustAllCerts,</span><br><span class="line">                    <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">            <span class="comment">// Create an ssl socket factory with our all-trusting manager</span></span><br><span class="line">            <span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext</span><br><span class="line">                    .getSocketFactory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sslSocketFactory;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Api包</strong>：定义表对应的api接口类，接口类中定义各个业务方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserApi</span></span>&#123;</span><br><span class="line">    String HOST = <span class="string">"https://api.bmob.cn/1/classes/"</span>;</span><br><span class="line">    String TABLE_URL = <span class="string">"_User"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(TABLE_URL + <span class="meta-string">"/&#123;objectId&#125;"</span>)</span></span><br><span class="line">    Observable&lt;UserBean&gt; getData(<span class="meta">@Path(<span class="meta-string">"objectId"</span>)</span> String objectId);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(TABLE_URL)</span></span><br><span class="line">    Observable&lt;ListObjectBean&lt;UserBean&gt;&gt; getListData();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(TABLE_URL)</span></span><br><span class="line">    Observable&lt;UserBean&gt; postData(<span class="meta">@Body</span> UserBean userBean);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PUT(TABLE_URL + <span class="meta-string">"/&#123;objectId&#125;"</span>)</span></span><br><span class="line">    Observable&lt;UserBean&gt; putData(<span class="meta">@Path(<span class="meta-string">"objectId"</span>)</span> String objectId, <span class="meta">@Body</span> UserBean userBean);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DELETE(TABLE_URL + <span class="meta-string">"/&#123;objectId&#125;"</span>)</span></span><br><span class="line">    Observable&lt;UserBean&gt; deleteData(<span class="meta">@Path(<span class="meta-string">"objectId"</span>)</span> String objectId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Bean包</strong>：定义与表字段对应的实体类，其中ListObjectBean是专门处理list数据的，由于采用gson自动转化，所以需要在List<t>包裹一层；BaseBean是实体基类，定义一些公共属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListObjectBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getResults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResults</span><span class="params">(List&lt;T&gt; results)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.results = results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>基于的是bomb的云服务器后台，bomb后台提供的restful接口方式是基于表形式的，后台提供的服务接口有限，目前本框架暂时只支持以下五种基于表形式的请求接口，有其它需求后期再考虑扩展。（已下以rentout_info表为例，由于只是测试使用，如果是mvp架构，实际使用可以将Observable的获取放入model层）</p><h3 id="1、Get方式（获取单条数据）"><a href="#1、Get方式（获取单条数据）" class="headerlink" title="1、Get方式（获取单条数据）"></a>1、Get方式（获取单条数据）</h3><p>   入参 :   objectId（表objectId）</p><p>   回调 :   成功回调 —&gt; RentOutInfoBean实体=&gt;与表字段对应的实体类<br>            失败回调—&gt; Throwable异常对象</p><p>   举例 :<br>   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rxManager</span><span class="selector-class">.register</span>(RetrofitCreateHelper.createApi(RentOutApi.class, RentOutApi.HOST).getData(objectId)</span><br><span class="line">                     .compose(RxHelper.&lt;RentOutInfoBean&gt;rxSchedulerHelper()).subscribe(new Consumer&lt;RentOutInfoBean&gt;() &#123;</span><br><span class="line">                         <span class="variable">@Override</span></span><br><span class="line">                         public void accept(RentOutInfoBean result) throws Exception &#123;</span><br><span class="line">                             if (result != null) &#123;</span><br><span class="line">                                 StringBuilder sb = new StringBuilder();</span><br><span class="line">                                 sb.append(result.getObjectId() + <span class="string">":"</span> + result.getCity() + <span class="string">":"</span> + result.getContent() + <span class="string">"\n"</span>);</span><br><span class="line">                                 tvResult.setText(sb.toString());</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                         <span class="variable">@Override</span></span><br><span class="line">                         public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                             ToastUtil.showLong(MainActivity.this, throwable.toString());</span><br><span class="line">                             tvResult.setText(throwable.toString());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;));</span><br></pre></td></tr></table></figure></p><h3 id="2、Get方式（获取多条数据）"><a href="#2、Get方式（获取多条数据）" class="headerlink" title="2、Get方式（获取多条数据）"></a>2、Get方式（获取多条数据）</h3><p>   入参 :   无</p><p>   回调 :   成功回调 —&gt;ListObjectBean<rentoutinfobean>=&gt;含有List<rentoutinfobean><br>   失败回调—&gt; Throwable异常对象</rentoutinfobean></rentoutinfobean></p><p>   举例 :<br>   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rxManager</span><span class="selector-class">.register</span>(RetrofitCreateHelper.createApi(RentOutApi.class, RentOutApi.HOST)</span><br><span class="line">                    .getListData().compose(RxHelper.&lt;ListObjectBean&lt;RentOutInfoBean&gt;&gt;rxSchedulerHelper())</span><br><span class="line">                    .subscribe(new Consumer&lt;ListObjectBean&lt;RentOutInfoBean&gt;&gt;() &#123;</span><br><span class="line">                        <span class="variable">@Override</span></span><br><span class="line">                        public void accept(ListObjectBean&lt;RentOutInfoBean&gt; result) throws Exception &#123;</span><br><span class="line">                            if (result != null) &#123;</span><br><span class="line">                                List&lt;RentOutInfoBean&gt; rentOutInfoBeans = result.getResults();</span><br><span class="line">                                if (rentOutInfoBeans != null &amp;&amp; rentOutInfoBeans.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    StringBuilder sb = new StringBuilder();</span><br><span class="line">                                    for (RentOutInfoBean <span class="attribute">rentOutInfoBean </span>: rentOutInfoBeans) &#123;</span><br><span class="line">                                        sb.append(rentOutInfoBean.getObjectId() + <span class="string">":"</span> + rentOutInfoBean.getCity() + <span class="string">":"</span> + rentOutInfoBean.getContent() + <span class="string">"\n"</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    tvResult.setText(sb.toString());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                        <span class="variable">@Override</span></span><br><span class="line">                        public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                            ToastUtil.showLong(MainActivity.this, throwable.toString());</span><br><span class="line">                            tvResult.setText(throwable.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br></pre></td></tr></table></figure></p><h3 id="3、Post方式（添加单条数据）"><a href="#3、Post方式（添加单条数据）" class="headerlink" title="3、Post方式（添加单条数据）"></a>3、Post方式（添加单条数据）</h3><p>入参 :   RentOutInfoBean实体</p><p>回调 :   成功回调 —&gt;RentOutInfoBean实体=&gt;只包含objectId和createdAt字段    失败回调—&gt; Throwable异常对象</p><p> 举例 :<br> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RentOutInfoBean testBean = <span class="keyword">new</span> RentOutInfoBean();</span><br><span class="line">              testBean.setLastTime(<span class="string">"131241341"</span>);</span><br><span class="line">              testBean.setContent(<span class="string">"13413411314ssa3"</span>);</span><br><span class="line">              testBean.setCity(<span class="string">"哈尔滨"</span>);</span><br><span class="line">              rxManager.register(RetrofitCreateHelper.createApi(RentOutApi.class, RentOutApi.HOST).postData(testBean)</span><br><span class="line">                      .compose(RxHelper.&lt;RentOutInfoBean&gt;rxSchedulerHelper()).subscribe(<span class="keyword">new</span> Consumer&lt;RentOutInfoBean&gt;() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(RentOutInfoBean result)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                              <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  tvResult.setText(result.getObjectId());</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                          <span class="meta">@Override</span></span><br><span class="line">                          <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                              ToastUtil.showLong(MainActivity.<span class="keyword">this</span>, throwable.toString());</span><br><span class="line">                              tvResult.setText(throwable.toString());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;));</span><br></pre></td></tr></table></figure></p><h3 id="4、Put方式（修改单条数据）"><a href="#4、Put方式（修改单条数据）" class="headerlink" title="4、Put方式（修改单条数据）"></a>4、Put方式（修改单条数据）</h3><p>   入参 :   objectId  </p><p>   RentOutInfoBean实体=&gt;包含要修改的字段<br>   回调 :   成功回调 —&gt;RentOutInfoBean实体=&gt;只包含updatedAt字段失败回调—&gt; Throwable异常对象</p><p>   举例 :<br>   <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RentOutInfoBean testBean1 = <span class="keyword">new</span> RentOutInfoBean();</span><br><span class="line">            testBean1.setCity(<span class="string">"上海"</span>);</span><br><span class="line">            rxManager.register(RetrofitCreateHelper.createApi(RentOutApi.class, RentOutApi.HOST).putData(objectId, testBean1)</span><br><span class="line">                    .compose(RxHelper.&lt;RentOutInfoBean&gt;rxSchedulerHelper()).subscribe(<span class="keyword">new</span> Consumer&lt;RentOutInfoBean&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(RentOutInfoBean result)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                tvResult.setText(result.getUpdatedAt());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ToastUtil.showLong(MainActivity.<span class="keyword">this</span>, throwable.toString());</span><br><span class="line">                            tvResult.setText(throwable.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br></pre></td></tr></table></figure></p><h3 id="5、Delete方式（删除单条数据）"><a href="#5、Delete方式（删除单条数据）" class="headerlink" title="5、Delete方式（删除单条数据）"></a>5、Delete方式（删除单条数据）</h3><p>   入参 :   objectId</p><p>   回调 :   成功回调 —&gt;RentOutInfoBean实体=&gt;只包含msg字段 值为”ok”失败回调—&gt; Throwable异常对象</p><p>   举例 :<br>   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rxManager</span><span class="selector-class">.register</span>(RetrofitCreateHelper.createApi(RentOutApi.class, RentOutApi.HOST).deleteData(objectId)</span><br><span class="line">                     .compose(RxHelper.&lt;RentOutInfoBean&gt;rxSchedulerHelper()).subscribe(new Consumer&lt;RentOutInfoBean&gt;() &#123;</span><br><span class="line">                         <span class="variable">@Override</span></span><br><span class="line">                         public void accept(RentOutInfoBean result) throws Exception &#123;</span><br><span class="line">                             if (result != null) &#123;</span><br><span class="line">                                 tvResult.setText(result.getMsg());</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">                         <span class="variable">@Override</span></span><br><span class="line">                         public void accept(Throwable throwable) throws Exception &#123;</span><br><span class="line">                             ToastUtil.showLong(MainActivity.this, throwable.toString());</span><br><span class="line">                             tvResult.setText(throwable.toString());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;));</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于目前还是处于第一版，再加上bomb后台的restful接口服务限制，只提供了一些基础通用的请求方式，还有许多需要补充与完善的地方，比如文件上传、模糊搜索等一些高级请求。 </p><p>参考链接：<br><a href="https://blog.csdn.net/qiang_xi/article/details/53959437" target="_blank" rel="noopener">https://blog.csdn.net/qiang_xi/article/details/53959437</a></p><p>Demo链接：<br><a href="https://github.com/penglian/TestRestful" target="_blank" rel="noopener">https://github.com/penglian/TestRestful</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;基于Rxjava+okhttp+retrofit搭建的网络请求框架，封装了练手项目中的各个表对应的基本网络请求&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="//plstyle.cn/tags/android/"/>
    
      <category term="rxjava" scheme="//plstyle.cn/tags/rxjava/"/>
    
      <category term="retrofit" scheme="//plstyle.cn/tags/retrofit/"/>
    
      <category term="okhttp" scheme="//plstyle.cn/tags/okhttp/"/>
    
  </entry>
  
</feed>
